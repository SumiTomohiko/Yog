/**
 * inst <name>
 * (operand_type operand_name, ...)
 * (pop_value, ...)
 * <- top bottom ->
 * (push_value, ...)
 * <- top bottom ->
 * {
 *      C code.
 * }
 */

inst load_special
(ID id) 
()
(val) 
{
}

inst pop
()
(val)
()
{
}

inst push_const
(uint8_t index)
()
(val)
{
    val = CONSTS(index);
}

inst call_method
(ID method, uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
(...)
(...)
{
    POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);

    YogVal receiver = POP();
    YogVal attr = YogVal_get_attr(ENV, receiver, method);
    call_method(ENV, THREAD, receiver, attr, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
}

inst store_name
(ID id) 
(val) 
()
{
    YogVal key = ID2VAL(id);
    YogTable_insert(ENV, NAME_VARS(CUR_FRAME), key, val);
}

inst store_local
(uint8_t index)
(val)
()
{
    LOCAL_VARS(CUR_FRAME)->items[index] = val;
}

inst call_command 
(ID command, uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
()
()
{
    POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);

    YogVal val = lookup_builtins(ENV, command);
    YogVal unbound_self = YUNDEF;
    call_method(ENV, THREAD, unbound_self, val, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
}

inst make_package_method
()
(code)
(method)
{
    YogBoundMethod* m = YogBoundMethod_new(ENV);
    m->self = NAME_FRAME(CUR_FRAME)->self;
    m->code = VAL2PTR(code);

    method = OBJ2VAL(m);
}

inst call_function
(uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
(...)
(...)
{
    POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);

    YogVal callee = POP();
    YogVal unbound_self = YUNDEF;
    call_method(ENV, THREAD, unbound_self, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
}

inst load_name
(ID id) 
()
(val)
{
    YogVal key = ID2VAL(id);
    if (!YogTable_lookup(ENV, NAME_VARS(CUR_FRAME), key, &val)) {
        val = lookup_builtins(ENV, id);
        Yog_assert(ENV, !IS_UNDEF(val), "Can't find package var.");
    }
}

inst load_local
(uint8_t index) 
()
(val)
{
    val = LOCAL_VARS(CUR_FRAME)->items[index];
}

inst jump
(pc_t dest)
()
()
{
    JUMP(dest);
}

inst jump_if_false
(pc_t dest)
(val)
()
{
    YogValType type = VAL_TYPE(val);
    if ((type == VAL_NIL) || ((type == VAL_BOOL) && !VAL2BOOL(val))) {
        JUMP(dest);
    }
}

inst dup 
()
(val)
(val, val)
{
}

inst make_package_block
()
(code)
(block)
{
    YogPackageBlock* b = YogPackageBlock_new(env);
    YogCode* c = VAL2PTR(code);
    BLOCK(b)->code = c;
    b->self = NAME_FRAME(CUR_FRAME)->self;
    b->vars = NAME_FRAME(CUR_FRAME)->vars;
    block = OBJ2VAL(b);
}

inst make_klass
()
(code, super, name)
(...)
{
    YogKlass* super_klass = (YogKlass*)VAL2OBJ(super);
    YogKlass* kls = YogKlass_new(ENV, YogObj_allocate, NULL, super_klass);
    kls->name = VAL2ID(name);
    YogTable* attrs = YOGOBJ(kls)->attrs = YogTable_new_symbol_table(ENV);
    YogCode* c = VAL2PTR(code);

    YogKlassFrame* frame = YogKlassFrame_new(ENV);
    setup_script_frame(ENV, SCRIPT_FRAME(frame), c);
    NAME_FRAME(frame)->self = OBJ2VAL(kls);
    NAME_FRAME(frame)->vars = attrs;

    PUSH_FRAME(FRAME(frame));
}

inst make_method
()
(code)
(method)
{
    YogUnboundMethod* m = YogUnboundMethod_new(ENV);
    m->code = VAL2PTR(code);
    method = OBJ2VAL(m);
}

inst push_self_name
()
()
(self)
{
    self = NAME_FRAME(CUR_FRAME)->self;
}

inst ret
()
(val)
(val)
{
    POP_FRAME();
    PC = SCRIPT_FRAME(CUR_FRAME)->pc;
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
