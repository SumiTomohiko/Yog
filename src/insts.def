/**
 * inst <name>
 * (operand_type operand_name, ...)
 * (pop_value, ...)
 * <- top bottom ->
 * (push_value, ...)
 * <- top bottom ->
 * {
 *      C code.
 * }
 */

inst load_special
(ID id) 
()
(val) 
{
}

inst pop
()
(val)
()
{
}

inst push_const
(uint8_t index)
()
(val)
{
    val = CONSTS(index);
}

inst make_string 
(uint8_t index)
()
(val) 
{
    YogVal c = CONSTS(index);
    val = YogString_clone(ENV, c);
}

inst call_method
(ID method, uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
(...) depth: argc + 2 * kwargc + blockargc + varargc + varkwargc
(...) depth: 1
{
    POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);

    YogVal receiver = POP();
    YogVal attr = YogVal_get_attr(ENV, receiver, method);
    call_method(ENV, receiver, attr, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);

    POP_LOCALS(ENV);
    POP_LOCALS(ENV);
    POP_LOCALS(ENV);
}

inst store_name
(ID id) 
(val) 
()
{
    YogVal key = ID2VAL(id);
    YogVal vars = NAME_VARS(CUR_FRAME);
    YogTable_insert(ENV, vars, key, val);
}

inst store_local
(uint8_t index)
(val)
()
{
    YogVal vars = LOCAL_VARS(CUR_FRAME);
    MODIFY(ENV, PTR_AS(YogValArray, vars)->items[index], val);
}

inst call_command 
(ID command, uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
(...) depth: argc + 2 * kwargc + blockargc + varargc + varkwargc
(...) depth: 1
{
    POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);

    YogVal callee = YUNDEF;
    if (!lookup_frame_vars(ENV, CUR_FRAME, command, &callee)) {
        callee = lookup_builtins(ENV, command);
    }

    YogVal unbound_self = YUNDEF;
    call_method(ENV, unbound_self, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);

    POP_LOCALS(ENV);
    POP_LOCALS(ENV);
    POP_LOCALS(ENV);
}

inst make_package_method
()
(code)
(method)
{
    method = YogBoundMethod_new(ENV);
    setup_script_method(ENV, method, code);
    YogVal self = PTR_AS(YogNameFrame, CUR_FRAME)->self;
    MODIFY(env, PTR_AS(YogBoundMethod, method)->self, self);
}

inst call_function
(uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
(...) depth: argc + 2 * kwargc + blockargc + varargc + varkwargc
(...) depth: 1
{
    POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);

    YogVal callee = POP();
    YogVal unbound_self = YUNDEF;
    call_method(ENV, unbound_self, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);

    POP_LOCALS(ENV);
    POP_LOCALS(ENV);
    POP_LOCALS(ENV);
}

inst load_global
(ID id)
()
(val) 
{
    YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
    if (!YogTable_lookup(ENV, globals, ID2VAL(id), &val)) {
        val = lookup_builtins(ENV, id);
    }
    YOG_ASSERT(ENV, !IS_UNDEF(val), "can't find global variable");
}

inst load_name
(ID id) 
()
(val)
{
    YogVal key = ID2VAL(id);
    if (!YogTable_lookup(ENV, NAME_VARS(CUR_FRAME), key, &val)) {
        val = lookup_builtins(ENV, id);
        YOG_ASSERT(ENV, !IS_UNDEF(val), "Can't find package var.");
    }
}

inst load_local
(uint8_t index) 
()
(val)
{
    YogVal vars = LOCAL_VARS(CUR_FRAME);
    val = PTR_AS(YogValArray, vars)->items[index];
}

inst jump
(pc_t dest)
()
()
{
    JUMP(dest);
}

inst jump_if_false
(pc_t dest)
(val)
()
{
    if (IS_NIL(val) || IS_FALSE(val)) {
        JUMP(dest);
    }
}

inst dup 
()
(val)
(val, val)
{
}

inst make_block
()
(code)
(block) 
{
    block = YogBlock_new(ENV);
    MODIFY(env, PTR_AS(YogBasicBlock, block)->code, code);
    MODIFY(env, PTR_AS(YogBlock, block)->locals, PTR_AS(YogMethodFrame, CUR_FRAME)->vars);

    unsigned int outer_depth = PTR_AS(YogCode, code)->outer_size;
    YogVal outer_vars = make_outer_vars(env, outer_depth);
    PTR_AS(YogBlock, block)->outer_vars = outer_vars;
    MODIFY(env, PTR_AS(YogBlock, block)->globals, SCRIPT_FRAME(CUR_FRAME)->globals);
}

inst make_klass
()
(code, super, name)
(...) depth: 1
{
    YogVal kls = YUNDEF;
    YogVal frame = YUNDEF;
    YogVal attrs = YUNDEF;
    PUSH_LOCALS3(ENV, kls, frame, attrs);

    kls = YogKlass_new(ENV, NULL, super);
    PTR_AS(YogKlass, kls)->name = VAL2ID(name);
    PTR_AS(YogObj, kls)->attrs = YUNDEF;
    attrs = YogTable_new_symbol_table(ENV);
    MODIFY(env, PTR_AS(YogObj, kls)->attrs, attrs);

    frame = YogKlassFrame_new(ENV);
    setup_script_frame(ENV, frame, code);
    MODIFY(env, PTR_AS(YogNameFrame, frame)->self, kls);
    MODIFY(env, PTR_AS(YogNameFrame, frame)->vars, attrs);

    PUSH_FRAME(frame);

    POP_LOCALS(ENV);
}

inst make_method
()
(code)
(method)
{
    method = YogUnboundMethod_new(ENV);
    setup_script_method(ENV, method, code);
}

inst push_self_name
()
()
(self)
{
    self = PTR_AS(YogNameFrame, CUR_FRAME)->self;
}

inst ret
()
(val)
(val)
{
    POP_FRAME();
    if (!IS_PTR(CUR_FRAME) || PTR_AS(YogFrame, CUR_FRAME)->type == FRAME_C) {
        return val;
    }

    PC = SCRIPT_FRAME(CUR_FRAME)->pc;
}

inst store_nonlocal
(uint8_t level, uint8_t index) 
(val)
() 
{
    YogVal* ptr = get_outer_vars_ptr(ENV, level, index);
    *ptr = val;
}

inst load_nonlocal 
(uint8_t level, uint8_t index) 
()
(val)
{
    YogVal* ptr = get_outer_vars_ptr(ENV, level, index);
    val = *ptr;
}

inst store_global 
(ID name) 
(val) 
()
{
    YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
    YogTable_insert(ENV, globals, ID2VAL(name), val);
}

inst load_attr
(ID name)
(val)
(retval)
{
    retval = YogVal_get_attr(ENV, val, name);
}

inst make_array
(uint8_t size)
(...) depth: size
(array)
{
    array = YogArray_of_size(ENV, size);
    unsigned int i;
    for (i = 0; i < size; i++) {
        YogVal body = PTR_AS(YogArray, array)->body;
        PTR_AS(YogValArray, body)->items[size - i - 1] = POP();
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
