/**
 * inst <name>
 * (operand_type operand_name, ...)
 * (pop_value, ...)
 * <- top bottom ->
 * (push_value, ...)
 * <- top bottom ->
 * {
 *      C code.
 * }
 */

inst pop
()
(val)
()
{
}

inst push_const
(uint8_t index)
()
(val)
{
    val = CONSTS(index);
}

inst make_string
(uint8_t index)
()
(val)
{
    YogVal c = CONSTS(index);
    val = YogString_clone(env, c);
}

inst store_name
(ID id)
(val)
()
{
    YogVal key = ID2VAL(id);
    YogVal vars = NAME_VARS(CUR_FRAME);
    YogTable_insert(env, vars, key, val);
}

inst store_local
(uint8_t index)
(val)
()
{
    YogVal vars = LOCAL_VARS(CUR_FRAME);
    YogGC_UPDATE_PTR(env, PTR_AS(YogValArray, vars), items[index], val);
}

inst make_block
()
(code)
(method)
{
    SAVE_LOCALS_TO_NAME(env, make_block);
    YogVal f = YUNDEF;
    YogVal self = YUNDEF;
    PUSH_LOCALS2(env, f, self);

    f = YogFunction_new(env);
    setup_script_function(env, f, code);
    YogGC_UPDATE_PTR(env, PTR_AS(YogFunction, f), frame_to_long_return, PTR_AS(YogScriptFrame, CUR_FRAME)->frame_to_long_return);
    YogGC_UPDATE_PTR(env, PTR_AS(YogFunction, f), frame_to_long_break, CUR_FRAME);

    switch (PTR_AS(YogFrame, CUR_FRAME)->type) {
    case FRAME_METHOD:
        self = PTR_AS(YogValArray, LOCAL_VARS(CUR_FRAME))->items[0];
        break;
    case FRAME_PKG:
    case FRAME_CLASS:
        self = PTR_AS(YogNameFrame, CUR_FRAME)->self;
        break;
    case FRAME_C:
    case FRAME_FINISH:
    default:
        YOG_BUG(env, "invalid frame (0x%08x)", CUR_FRAME);
        break;
    }

    method = YogInstanceMethod_new(env);
    YogGC_UPDATE_PTR(env, PTR_AS(YogInstanceMethod, method), self, self);
    YogGC_UPDATE_PTR(env, PTR_AS(YogInstanceMethod, method), f, f);

    RESTORE_LOCALS_FROM_NAME(env, make_block);
}

inst make_function
(ID name)
(code)
(f)
{
    f = YogFunction_new(env);
    setup_script_function(env, f, code);
    PTR_AS(YogFunction, f)->name = name;
    if (PTR_AS(YogFrame, CUR_FRAME)->type == FRAME_CLASS) {
        YogVal klass = PTR_AS(YogNameFrame, CUR_FRAME)->self;
        YogGC_UPDATE_PTR(env, PTR_AS(YogFunction, f), klass, klass);
    }
}

inst call_function
(uint8_t argc, uint8_t kwargc, uint8_t varargc, uint8_t varkwargc, uint8_t blockargc, uint8_t left, uint8_t middle, uint8_t right)
(...) depth: argc + 2 * kwargc + varargc + varkwargc + blockargc
(...) depth: left + middle + right
{
    SAVE_LOCALS_TO_NAME(env, call_function);

    YogVal callee = POP();
    POP_ARGS(args, kwargs, vararg, varkwarg, blockarg);
    set_lhs_composition(env, left, middle, right);

    YogVal klass = YogVal_get_class(env, callee);
    if (PTR_AS(YogClass, klass)->exec == NULL) {
        YogError_raise_TypeError(env, "%C is not callable", callee);
    }
    YOG_ASSERT(env, PTR_AS(YogClass, klass)->exec != NULL, "uncallable");
    PTR_AS(YogClass, klass)->exec(env, callee, argc, args, kwargc, kwargs, vararg, varkwarg, blockarg);

    RESTORE_LOCALS_FROM_NAME(env, call_function);
}

inst load_global
(ID id)
()
(val)
{
    YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
    if (!YogTable_lookup(env, globals, ID2VAL(id), &val)) {
        val = lookup_builtins(env, id);
    }
    if (IS_UNDEF(val)) {
        YogVal name = YogVM_id2name(env, env->vm, id);
        YogError_raise_NameError(env, "name \"%S\" is not defined", name);
    }
}

inst load_name
(ID id)
()
(val)
{
    YogVal key = ID2VAL(id);
    if (!YogTable_lookup(env, NAME_VARS(CUR_FRAME), key, &val)) {
        val = lookup_builtins(env, id);
    }
    if (IS_UNDEF(val)) {
        YogVal name = YogVM_id2name(env, env->vm, id);
        YogError_raise_NameError(env, "name \"%S\" is not defined", name);
    }
}

inst load_local
(uint8_t index)
()
(val)
{
    YogVal vars = LOCAL_VARS(CUR_FRAME);
    val = PTR_AS(YogValArray, vars)->items[index];
}

inst load_super
()
()
(val)
{
    SAVE_LOCALS_TO_NAME(env, load_super);
    YogVal klass = YUNDEF;
    YogVal super = YUNDEF;
    YogVal attr = YUNDEF;
    YogVal self = YUNDEF;
    YogVal c = YUNDEF;
    PUSH_LOCALS5(env, klass, super, attr, self, c);

    if (PTR_AS(YogFrame, CUR_FRAME)->type == FRAME_METHOD) {
        klass = PTR_AS(YogMethodFrame, CUR_FRAME)->klass;
        super = PTR_AS(YogClass, klass)->super;
        ID name = PTR_AS(YogMethodFrame, CUR_FRAME)->name;
        attr = YogClass_get_attr(env, super, name);
        if (IS_UNDEF(attr)) {
            YogError_raise_AttributeError(env, "super not found");
        }
        self = PTR_AS(YogValArray, LOCAL_VARS(CUR_FRAME))->items[0];
        c = YogVal_get_class(env, self);
        val = YogVal_get_descr(env, attr, self, c);
    }

    RESTORE_LOCALS_FROM_NAME(env, load_super);
}

inst jump
(pc_t dest)
()
()
{
    JUMP(dest);
}

inst jump_if_true
(pc_t dest)
(val)
()
{
    if (YOG_TEST(val)) {
        JUMP(dest);
    }
}

inst jump_if_false
(pc_t dest)
(val)
()
{
    if (!YOG_TEST(val)) {
        JUMP(dest);
    }
}

inst jump_if_defined
(uint8_t index, pc_t dest)
()
()
{
    SAVE_LOCALS_TO_NAME(env, jump_if_defined);
    YogVal val = YUNDEF;
    PUSH_LOCAL(env, val);

    val = PTR_AS(YogValArray, LOCAL_VARS(CUR_FRAME))->items[index];
    if (!IS_UNDEF(val)) {
        JUMP(dest);
    }

    RESTORE_LOCALS_FROM_NAME(env, jump_if_defined);
}

inst dup
()
(val)
(val, val)
{
}

inst make_module
(ID name)
(code)
(...) depth: 2
{
    SAVE_LOCALS_TO_NAME(env, make_module);
    YogVal module = YUNDEF;
    YogVal frame = YUNDEF;
    PUSH_LOCALS2(env, module, frame);

    module = YogModule_new(env);
    PTR_AS(YogModule, module)->name = name;
    PUSH(module);

    set_lhs_composition(env, 1, 0, 0);

    frame = YogClassFrame_new(env);
    setup_script_frame(env, frame, code);
    YogGC_UPDATE_PTR(env, PTR_AS(YogNameFrame, frame), vars, PTR_AS(YogObj, module)->attrs);
    YogGC_UPDATE_PTR(env, PTR_AS(YogScriptFrame, frame), globals, PTR_AS(YogScriptFrame, CUR_FRAME)->globals);

    PUSH_FRAME(frame);

    RESTORE_LOCALS_FROM_NAME(env, make_module);
}

inst make_class
()
(code, super, name)
(...) depth: 2
{
    SAVE_LOCALS_TO_NAME(env, make_class);
    YogVal kls = YUNDEF;
    YogVal frame = YUNDEF;
    YogVal attrs = YUNDEF;
    PUSH_LOCALS3(env, kls, frame, attrs);

    kls = YogClass_new(env, NULL, super);
    PTR_AS(YogClass, kls)->name = VAL2ID(name);
    PTR_AS(YogObj, kls)->attrs = YUNDEF;
    attrs = YogTable_new_symbol_table(env);
    YogGC_UPDATE_PTR(env, PTR_AS(YogObj, kls), attrs, attrs);
    PUSH(kls);

    set_lhs_composition(env, 1, 0, 0);

    frame = YogClassFrame_new(env);
    setup_script_frame(env, frame, code);
    YogGC_UPDATE_PTR(env, PTR_AS(YogNameFrame, frame), self, kls);
    YogGC_UPDATE_PTR(env, PTR_AS(YogNameFrame, frame), vars, attrs);
    YogGC_UPDATE_PTR(env, PTR_AS(YogScriptFrame, frame), globals, PTR_AS(YogScriptFrame, CUR_FRAME)->globals);

    PUSH_FRAME(frame);

    RESTORE_LOCALS_FROM_NAME(env, make_class);
}

inst ret
(uint8_t n)
(...) depth: n
()
{
    move_returned_value(env, n);

    POP_FRAME();
    PC = SCRIPT_FRAME(CUR_FRAME)->pc;
}

inst store_nonlocal
(uint8_t level, uint8_t index)
(val)
()
{
    YogVal* ptr = get_outer_vars_ptr(env, level, index);
    *ptr = val;
}

inst load_nonlocal
(uint8_t level, uint8_t index)
()
(val)
{
    YogVal* ptr = get_outer_vars_ptr(env, level, index);
    val = *ptr;
}

inst store_global
(ID name)
(val)
()
{
    YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
    YogTable_insert(env, globals, ID2VAL(name), val);
}

inst load_attr
(ID name)
(obj)
(...) depth: 1
{
    SAVE_LOCALS_TO_NAME(env, load_attr);
    YogVal klass = YUNDEF;
    PUSH_LOCAL(env, klass);

    klass = YogVal_get_class(env, obj);
    GetAttrExecutor exec = PTR_AS(YogClass, klass)->exec_get_attr;
    if (exec == NULL) {
        exec = exec_get_attr;
    }

    set_lhs_composition(env, 1, 0, 0);
    exec(env, obj, name);

    RESTORE_LOCALS_FROM_NAME(env, load_attr);
}

inst make_array
(uint8_t size)
(...) depth: size
(array)
{
    array = YogArray_of_size(env, size);
    uint_t i;
    for (i = 0; i < size; i++) {
        YogVal body = PTR_AS(YogArray, array)->body;
        YogGC_UPDATE_PTR(env, PTR_AS(YogValArray, body), items[size - i - 1], POP());
    }
    PTR_AS(YogArray, array)->size = size;
}

inst make_dict
(uint8_t size)
(...) depth: 2 * size
(dict)
{
    SAVE_LOCALS_TO_NAME(env, make_dict);
    YogVal key = YUNDEF;
    YogVal value = YUNDEF;
    PUSH_LOCALS2(env, key, value);

    dict = YogDict_new(env);
    uint_t i;
    for (i = 0; i < size; i++) {
        value = POP();
        key = POP();
        YogDict_set(env, dict, key, value);
    }

    RESTORE_LOCALS_FROM_NAME(env, make_dict);
}

inst make_set
(uint8_t size)
(...) depth: size
(set)
{
    SAVE_LOCALS_TO_NAME(env, make_set);
    YogVal elem = YUNDEF;
    PUSH_LOCAL(env, elem);

    set = YogSet_new(env);
    uint_t i;
    for (i = 0; i < size; i++) {
        elem = POP();
        YogSet_add(env, set, elem);
    }

    RESTORE_LOCALS_FROM_NAME(env, make_set);
}

inst finish
()
(val)
()
{
    POP_JMPBUF(env);
    POP_FRAME();
    RETURN(env, val);
}

inst print_top
()
(val)
()
{
    YogVal s = YogEval_call_method(env, val, "to_s", 0, NULL);
    YOG_ASSERT(env, IS_PTR(s) && (BASIC_OBJ_TYPE(s) == TYPE_STRING), "object isn't string");
    printf("=> %s\n", STRING_CSTR(s));
}

inst print_top_multi_value
()
(val)
()
{
    SAVE_LOCALS_TO_NAME(env, print_top_multi_value);
    YogVal s = YUNDEF;
    YogVal obj = YUNDEF;
    PUSH_LOCALS2(env, s, obj);

    printf("=>");

    YOG_ASSERT(env, IS_PTR(val), "invalid operand (0x%08x)", val);
    YOG_ASSERT(env, BASIC_OBJ_TYPE(val) == TYPE_ARRAY, "invalid operand type (0x%08x)", BASIC_OBJ_TYPE(val));
    uint_t size = YogArray_size(env, val);
    uint_t i;
    for (i = 0; i < size; i++) {
        obj = YogArray_at(env, val, i);
        s = YogEval_call_method(env, obj, "to_s", 0, NULL);
        YOG_ASSERT(env, IS_PTR(s), "invalid string (0x%08x)", s);
        YOG_ASSERT(env, BASIC_OBJ_TYPE(s) == TYPE_STRING, "invalid string type (0x%08x)", BASIC_OBJ_TYPE(s));
        printf(" %s", STRING_CSTR(s));
    }
    printf("\n");

    RESTORE_LOCALS_FROM_NAME(env, print_top_multi_value);
}

inst store_attr
(ID name)
(obj, val)
()
{
    SAVE_LOCALS_TO_NAME(env, store_attr);
    YogVal attr = YUNDEF;
    YogVal class_of_obj = YUNDEF;
    YogVal class_of_attr = YUNDEF;
    YogVal attr_name = YUNDEF;
    PUSH_LOCALS4(env, attr, class_of_obj, class_of_attr, attr_name);

    class_of_obj = YogVal_get_class(env, obj);
    BOOL has_attrs;
    if (IS_PTR(obj) && ((PTR_AS(YogBasicObj, obj)->flags & HAS_ATTRS) != 0)) {
        has_attrs = TRUE;
    }
    else {
        has_attrs = FALSE;
    }

    if (has_attrs) {
        attr = YogObj_get_attr(env, obj, name);
    }
    if (IS_UNDEF(attr)) {
        attr = YogObj_get_attr(env, class_of_obj, name);
    }
    if (!IS_UNDEF(attr)) {
        class_of_attr = YogVal_get_class(env, attr);
        void (*exec)(YogEnv*, YogVal, YogVal, YogVal) = PTR_AS(YogClass, class_of_attr)->exec_set_descr;
        if (exec != NULL) {
            set_lhs_composition(env, 0, 0, 0);
            exec(env, attr, obj, val);
        }
        else if (has_attrs) {
            YogObj_set_attr_id(env, obj, name, val);
        }
        else {
            YogError_raise_AttributeError(env, "can't set attribute to %C object", obj);
        }
    }
    else if (has_attrs) {
        YogObj_set_attr_id(env, obj, name, val);
    }
    else {
        attr_name = YogVM_id2name(env, env->vm, name);
        YogError_raise_AttributeError(env, "%C object has no attribute \"%S\"", obj, attr_name);
    }

    RESTORE_LOCALS_FROM_NAME(env, store_attr);
}

inst not
()
(val)
(b)
{
    if (YOG_TEST(val)) {
        b = YFALSE;
    }
    else {
        b = YTRUE;
    }
}

inst long_return
(uint8_t n)
(...) depth: n
()
{
    YogVal target_frame = SCRIPT_FRAME(CUR_FRAME)->frame_to_long_return;
    long_jump(env, n, JMP_RETURN, target_frame);
}

inst long_break
(uint8_t n)
(...) depth: n
()
{
    YogVal target_frame = SCRIPT_FRAME(CUR_FRAME)->frame_to_long_break;
    long_jump(env, n, JMP_BREAK, target_frame);
}

inst load_exception
()
()
(exc)
{
    exc = PTR_AS(YogThread, env->thread)->jmp_val;
}

inst match_exception
()
(klass, exc)
(b)
{
    if (YogVal_is_subclass_of(env, exc, klass)) {
        b = YTRUE;
    }
    else {
        b = YFALSE;
    }
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
