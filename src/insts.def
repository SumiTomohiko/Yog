/**
 * inst <name>
 * (operand_type operand_name, ...)
 * (pop_value, ...)
 * <- top bottom ->
 * (push_value, ...)
 * <- top bottom ->
 * {
 *      C code.
 * }
 */

inst load_special
(ID id) 
()
(val) 
{
}

inst push_const
(uint8_t index)
()
(val)
{
    val = CONSTS(index);
}

inst call_method
(ID method, uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
(...)
(...)
{
    YogVal args[argc];
    unsigned int i = 0;
    for (i = 0; i < argc; i++) {
        args[i] = POP();
    }
    YogVal receiver = POP();
    YogVal ret = YogThread_call_method_id(ENV, THREAD, receiver, method, argc, args);
    PUSH(ret);
}

inst store_pkg
(ID id) 
(val) 
()
{
    YogVal key = YogVal_symbol(id);
    YogTable_insert(ENV, PKG_VARS(CUR_FRAME), key, val);
}

inst store_local
(uint8_t index)
(val)
()
{
    LOCAL_VARS(CUR_FRAME)->items[index] = val;
}

inst call_command 
(ID command, uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
()
()
{
    YogVal args[argc];
    unsigned int i = 0;
    for (i = 0; i < argc; i++) {
        args[i] = POP();
    }
    YogThread_call_command(ENV, command, argc, args);
}

inst make_package_method
()
(code)
(method)
{
    YogBoundMethod* m = YogBoundMethod_new(ENV);
    m->self = YogVal_obj(YOGBASICOBJ(PKG_FRAME(CUR_FRAME)->pkg));
    m->code = YOGVAL_PTR(code);

    method = YogVal_obj(YOGBASICOBJ(m));
}

inst call_function
(uint8_t argc, uint8_t kwargc, uint8_t blockargc, uint8_t varargc, uint8_t varkwargc)
(...)
(...)
{
    YogVal varkwarg = YogVal_undef();
    if (varkwargc == 1) {
        varkwarg = POP();
    }

    YogVal vararg = YogVal_undef();
    if (varargc == 1) {
        vararg = POP();
    }

    YogVal blockarg = YogVal_undef();
    if (blockargc == 1) {
        blockarg = POP();
    }

    YogVal kwargs[2 * kwargc];
    unsigned int i = 0;
    for (i = kwargc; 0 < i; i--) {
        kwargs[2 * i - 1] = POP();
        kwargs[2 * i - 2] = POP();
    }

    YogVal args[argc];
    for (i = argc; 0 < i; i--) {
        args[i - 1] = POP();
    }

    YogVal callee = POP();
    Yog_assert(ENV, IS_OBJ(callee), "Callee is not object.");
    YogBasicObj* obj = YOGVAL_OBJ(callee);
    if (obj->klass == VM->builtin_bound_method_klass) {
        YogBuiltinBoundMethod* method = (YogBuiltinBoundMethod*)obj;
        YogVal val = call_builtin_bound_method(ENV, method, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
        PUSH(val);
    }
    else if (obj->klass == VM->bound_method_klass) {
        YogBoundMethod* method = (YogBoundMethod*)obj;
        YogVal self = method->self;
        YogCode* code = method->code;
        call_code(ENV, THREAD, self, code, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
    }
    else if (obj->klass == VM->builtin_unbound_method_klass) {
        YogBuiltinUnboundMethod* method = (YogBuiltinUnboundMethod*)obj;
        YogVal val = call_builtin_unbound_method(ENV, YogVal_undef(), method, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
        PUSH(val);
    }
    else if (obj->klass == VM->unbound_method_klass) {
        YogUnboundMethod* method = (YogUnboundMethod*)obj;
        YogVal self = YogVal_undef();
        YogCode* code = method->code;
        call_code(ENV, THREAD, self, code, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
    }
    else {
        Yog_assert(ENV, FALSE, "Callee is not callable.");
    }
}

inst load_pkg
(ID id) 
()
(val)
{
    YogVal key = YogVal_symbol(id);
    if (!YogTable_lookup(ENV, PKG_VARS(CUR_FRAME), key, &val)) {
        YogVal builtins_name = YogVal_symbol(INTERN(BUILTINS));
        YogVal builtins = YogVal_undef();
        if (!YogTable_lookup(ENV, VM->pkgs, builtins_name, &builtins)) {
            Yog_assert(ENV, FALSE, "Can't find builtins package.");
        }
        YogPkg* pkg = (YogPkg*)YOGVAL_OBJ(builtins);
        if (!YogTable_lookup(ENV, pkg->attrs, key, &val)) {
            Yog_assert(ENV, FALSE, "Can't find package var.");
        }
    }
}

inst load_local
(uint8_t index) 
()
(val)
{
    val = LOCAL_VARS(CUR_FRAME)->items[index];
}

inst jump
(pc_t dest)
()
()
{
    JUMP(dest);
}

inst jump_if_false
(pc_t dest)
(val)
()
{
    YogValType type = YOGVAL_TYPE(val);
    if ((type == VAL_NIL) || ((type == VAL_BOOL) && !YOGVAL_BOOL(val))) {
        JUMP(dest);
    }
}

inst dup 
()
(val)
(val, val)
{
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
