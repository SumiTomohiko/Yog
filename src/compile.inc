/**
 * This file was generated by "tools/inst.py src/insts.def" automatically.
 * DO NOT TOUCH!!
 */

static void 
CompileData_append_push_const(YogEnv* env, CompileData* data, uint8_t index)
{
    YogInst* inst = YogInst_new(env);
    inst->type = INST_OP;
    INST_OPERAND(inst) = OP(PUSH_CONST);

    PUSH_CONST_INDEX(inst) = index;

    data->last_inst->next = inst;
    data->last_inst = inst;
}

static void 
CompileData_append_call_method(YogEnv* env, CompileData* data, ID method, uint8_t argc)
{
    YogInst* inst = YogInst_new(env);
    inst->type = INST_OP;
    INST_OPERAND(inst) = OP(CALL_METHOD);

    CALL_METHOD_METHOD(inst) = method;
    CALL_METHOD_ARGC(inst) = argc;

    data->last_inst->next = inst;
    data->last_inst = inst;
}

static void 
CompileData_append_store_pkg(YogEnv* env, CompileData* data, ID id)
{
    YogInst* inst = YogInst_new(env);
    inst->type = INST_OP;
    INST_OPERAND(inst) = OP(STORE_PKG);

    STORE_PKG_ID(inst) = id;

    data->last_inst->next = inst;
    data->last_inst = inst;
}

static void 
CompileData_append_call_command(YogEnv* env, CompileData* data, ID command, uint8_t argc)
{
    YogInst* inst = YogInst_new(env);
    inst->type = INST_OP;
    INST_OPERAND(inst) = OP(CALL_COMMAND);

    CALL_COMMAND_COMMAND(inst) = command;
    CALL_COMMAND_ARGC(inst) = argc;

    data->last_inst->next = inst;
    data->last_inst = inst;
}

static void 
CompileData_append_make_func(YogEnv* env, CompileData* data)
{
    YogInst* inst = YogInst_new(env);
    inst->type = INST_OP;
    INST_OPERAND(inst) = OP(MAKE_FUNC);


    data->last_inst->next = inst;
    data->last_inst = inst;
}


static YogBinary* 
insts2bin(YogEnv* env, YogInst* inst) 
{
#define INIT_BIN_SIZE   (0)
    YogBinary* code = YogBinary_new(env, INIT_BIN_SIZE);
#undef INIT_BIN_SIZE

    while (inst != NULL) {
        switch (INST_OPERAND(inst)) {

        case OP(PUSH_CONST):
            {
                YogBinary_push_uint8(env, code, OP(PUSH_CONST));
                YogBinary_push_uint8(env, code, PUSH_CONST_INDEX(inst));
                break;
            }
        case OP(CALL_METHOD):
            {
                YogBinary_push_uint8(env, code, OP(CALL_METHOD));
                YogBinary_push_id(env, code, CALL_METHOD_METHOD(inst));
                YogBinary_push_uint8(env, code, CALL_METHOD_ARGC(inst));
                break;
            }
        case OP(STORE_PKG):
            {
                YogBinary_push_uint8(env, code, OP(STORE_PKG));
                YogBinary_push_id(env, code, STORE_PKG_ID(inst));
                break;
            }
        case OP(CALL_COMMAND):
            {
                YogBinary_push_uint8(env, code, OP(CALL_COMMAND));
                YogBinary_push_id(env, code, CALL_COMMAND_COMMAND(inst));
                YogBinary_push_uint8(env, code, CALL_COMMAND_ARGC(inst));
                break;
            }
        case OP(MAKE_FUNC):
            {
                YogBinary_push_uint8(env, code, OP(MAKE_FUNC));
                break;
            }
        default:
            Yog_assert(env, FALSE, "Unkown instruction.");
            break;
        }

        inst = inst->next;
    }

    return code;
}

/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
