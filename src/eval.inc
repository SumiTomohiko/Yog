/**
 * This file was generated by "../tools/inst.py insts.def .." automatically.
 * DO NOT TOUCH!!
 */

    case OP(LOAD_SPECIAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(POP):
        {
            POP();

            break;
        }
    case OP(PUSH_CONST):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = CONSTS(index);

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(MAKE_STRING):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            YogVal c = CONSTS(index);
            val = YogString_clone(ENV, c);

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(STORE_NAME):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
            YogVal key = ID2VAL(id);
            YogVal vars = NAME_VARS(CUR_FRAME);
            YogTable_insert(ENV, vars, key, val);

            POP_LOCALS(ENV);
            break;
        }
    case OP(STORE_LOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
            YogVal vars = LOCAL_VARS(CUR_FRAME);
            MODIFY(ENV, PTR_AS(YogValArray, vars)->items[index], val);

            POP_LOCALS(ENV);
            break;
        }
    case OP(MAKE_FUNCTION):
        {
            YogVal code = YUNDEF;
            YogVal f = YUNDEF;
            PUSH_LOCALS2(ENV, code, f);
            code = POP();
            f = YogFunction_new(ENV);
            setup_script_function(ENV, f, code);

            PUSH(f);
            POP_LOCALS(ENV);
            break;
        }
    case OP(CALL_FUNCTION):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
            YogVal callee = POP();
        
            (*PTR_AS(YogCallable, callee)->exec)(env, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
        
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);

            break;
        }
    case OP(LOAD_GLOBAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
            if (!YogTable_lookup(ENV, globals, ID2VAL(id), &val)) {
                val = lookup_builtins(ENV, id);
            }
            YOG_ASSERT(ENV, !IS_UNDEF(val), "can't find global variable");

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(LOAD_NAME):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            YogVal key = ID2VAL(id);
            if (!YogTable_lookup(ENV, NAME_VARS(CUR_FRAME), key, &val)) {
                val = lookup_builtins(ENV, id);
                YOG_ASSERT(ENV, !IS_UNDEF(val), "Can't find package var.");
            }

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(LOAD_LOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            YogVal vars = LOCAL_VARS(CUR_FRAME);
            val = PTR_AS(YogValArray, vars)->items[index];

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(JUMP):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(pc_t);
            JUMP(dest);

            break;
        }
    case OP(JUMP_IF_FALSE):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(pc_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
            if (IS_NIL(val) || IS_FALSE(val)) {
                JUMP(dest);
            }

            POP_LOCALS(ENV);
            break;
        }
    case OP(DUP):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();

            PUSH(val);
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(MAKE_KLASS):
        {
            YogVal code = YUNDEF;
            YogVal super = YUNDEF;
            YogVal name = YUNDEF;
            PUSH_LOCALS3(ENV, code, super, name);
            code = POP();
            super = POP();
            name = POP();
            YogVal kls = YUNDEF;
            YogVal frame = YUNDEF;
            YogVal attrs = YUNDEF;
            PUSH_LOCALS3(ENV, kls, frame, attrs);
        
            kls = YogKlass_new(ENV, NULL, super);
            PTR_AS(YogKlass, kls)->name = VAL2ID(name);
            PTR_AS(YogObj, kls)->attrs = YUNDEF;
            attrs = YogTable_new_symbol_table(ENV);
            MODIFY(env, PTR_AS(YogObj, kls)->attrs, attrs);
        
            frame = YogKlassFrame_new(ENV);
            setup_script_frame(ENV, frame, code);
            MODIFY(env, PTR_AS(YogNameFrame, frame)->self, kls);
            MODIFY(env, PTR_AS(YogNameFrame, frame)->vars, attrs);
            PTR_AS(YogScriptFrame, frame)->globals = PTR_AS(YogScriptFrame, CUR_FRAME)->globals;
        
            PUSH_FRAME(frame);
        
            POP_LOCALS(ENV);

            POP_LOCALS(ENV);
            break;
        }
    case OP(PUSH_SELF_NAME):
        {
            YogVal self = YUNDEF;
            PUSH_LOCAL(ENV, self);
            self = PTR_AS(YogNameFrame, CUR_FRAME)->self;

            PUSH(self);
            POP_LOCALS(ENV);
            break;
        }
    case OP(RET):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
            POP_FRAME();
            PC = SCRIPT_FRAME(CUR_FRAME)->pc;

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(STORE_NONLOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t level = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
            YogVal* ptr = get_outer_vars_ptr(ENV, level, index);
            *ptr = val;

            POP_LOCALS(ENV);
            break;
        }
    case OP(LOAD_NONLOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t level = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            YogVal* ptr = get_outer_vars_ptr(ENV, level, index);
            val = *ptr;

            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
    case OP(STORE_GLOBAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID name = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
            YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
            YogTable_insert(ENV, globals, ID2VAL(name), val);

            POP_LOCALS(ENV);
            break;
        }
    case OP(LOAD_ATTR):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID name = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            YogVal retval = YUNDEF;
            PUSH_LOCALS2(ENV, val, retval);
            val = POP();
            retval = YogVal_get_attr(ENV, val, name);

            PUSH(retval);
            POP_LOCALS(ENV);
            break;
        }
    case OP(MAKE_ARRAY):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t size = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal array = YUNDEF;
            PUSH_LOCAL(ENV, array);
            array = YogArray_of_size(ENV, size);
            unsigned int i;
            for (i = 0; i < size; i++) {
                YogVal body = PTR_AS(YogArray, array)->body;
                PTR_AS(YogValArray, body)->items[size - i - 1] = POP();
            }
            PTR_AS(YogArray, array)->size = size;

            PUSH(array);
            POP_LOCALS(ENV);
            break;
        }
    case OP(FINISH):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
            POP_FRAME();
            RETURN(ENV, val);

            POP_LOCALS(ENV);
            break;
        }
/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
