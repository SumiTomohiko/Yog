/**
 * This file was generated by "../tools/inst.py insts.def .." automatically.
 * DO NOT TOUCH!!
 */

    case OP(LOAD_SPECIAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(POP):
        {
            POP();

            break;
        }
    case OP(PUSH_CONST):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = CONSTS(index);

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(MAKE_STRING):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            YogVal c = CONSTS(index);
            val = YogString_clone(env, c);

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(STORE_NAME):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            YogVal key = ID2VAL(id);
            YogVal vars = NAME_VARS(CUR_FRAME);
            YogTable_insert(env, vars, key, val);

            POP_LOCALS(env);
            break;
        }
    case OP(STORE_LOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            YogVal vars = LOCAL_VARS(CUR_FRAME);
            PTR_AS(YogValArray, vars)->items[index] = val;

            POP_LOCALS(env);
            break;
        }
    case OP(MAKE_FUNCTION):
        {
            YogVal code = YUNDEF;
            YogVal f = YUNDEF;
            PUSH_LOCALS2(env, code, f);
            code = POP();
            f = YogFunction_new(env);
            setup_script_function(env, f, code);

            PUSH(f);
            POP_LOCALS(env);
            break;
        }
    case OP(CALL_FUNCTION):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
            YogVal callee = POP();
        
            YogVal klass = YogVal_get_klass(env, callee);
            YOG_ASSERT(env, PTR_AS(YogKlass, klass)->exec, "uncallable");
            PTR_AS(YogKlass, klass)->exec(env, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
        
            POP_LOCALS(env);
            POP_LOCALS(env);
            POP_LOCALS(env);

            break;
        }
    case OP(LOAD_GLOBAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
            if (!YogTable_lookup(env, globals, ID2VAL(id), &val)) {
                val = lookup_builtins(env, id);
            }
            if (IS_UNDEF(val)) {
                const char* name = YogVM_id2name(env, env->vm, id);
                YogError_raise_NameError(env, "name '%s' is not defined", name);
            }

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(LOAD_NAME):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            YogVal key = ID2VAL(id);
            if (!YogTable_lookup(env, NAME_VARS(CUR_FRAME), key, &val)) {
                val = lookup_builtins(env, id);
            }
            if (IS_UNDEF(val)) {
                const char* name = YogVM_id2name(env, env->vm, id);
                YogError_raise_NameError(env, "name '%s' is not defined", name);
            }

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(LOAD_LOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            YogVal vars = LOCAL_VARS(CUR_FRAME);
            val = PTR_AS(YogValArray, vars)->items[index];

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(JUMP):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(pc_t);
            JUMP(dest);

            break;
        }
    case OP(JUMP_IF_TRUE):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(pc_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            if (YOG_TEST(val)) {
                JUMP(dest);
            }

            POP_LOCALS(env);
            break;
        }
    case OP(JUMP_IF_FALSE):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(pc_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            if (!YOG_TEST(val)) {
                JUMP(dest);
            }

            POP_LOCALS(env);
            break;
        }
    case OP(DUP):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();

            PUSH(val);
            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(MAKE_MODULE):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID name = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal code = YUNDEF;
            PUSH_LOCAL(env, code);
            code = POP();
            YogVal module = YUNDEF;
            YogVal frame = YUNDEF;
            PUSH_LOCALS2(env, module, frame);
        
            module = YogModule_new(env);
            PTR_AS(YogModule, module)->name = name;
            PUSH(module);
        
            frame = YogNameFrame_new(env);
            setup_script_frame(env, frame, code);
            PTR_AS(YogNameFrame, frame)->vars = PTR_AS(YogObj, module)->attrs;
            PTR_AS(YogScriptFrame, frame)->globals = PTR_AS(YogScriptFrame, CUR_FRAME)->globals;
        
            PUSH_FRAME(frame);
        
            POP_LOCALS(env);

            POP_LOCALS(env);
            break;
        }
    case OP(MAKE_KLASS):
        {
            YogVal code = YUNDEF;
            YogVal super = YUNDEF;
            YogVal name = YUNDEF;
            PUSH_LOCALS3(env, code, super, name);
            code = POP();
            super = POP();
            name = POP();
            YogVal kls = YUNDEF;
            YogVal frame = YUNDEF;
            YogVal attrs = YUNDEF;
            PUSH_LOCALS3(env, kls, frame, attrs);
        
            kls = YogKlass_new(env, NULL, super);
            PTR_AS(YogKlass, kls)->name = VAL2ID(name);
            PTR_AS(YogObj, kls)->attrs = YUNDEF;
            attrs = YogTable_new_symbol_table(env);
            PTR_AS(YogObj, kls)->attrs = attrs;
        
            frame = YogKlassFrame_new(env);
            setup_script_frame(env, frame, code);
            PTR_AS(YogNameFrame, frame)->self = kls;
            PTR_AS(YogNameFrame, frame)->vars = attrs;
            PTR_AS(YogScriptFrame, frame)->globals = PTR_AS(YogScriptFrame, CUR_FRAME)->globals;
        
            PUSH_FRAME(frame);
        
            POP_LOCALS(env);

            POP_LOCALS(env);
            break;
        }
    case OP(PUSH_SELF_NAME):
        {
            YogVal self = YUNDEF;
            PUSH_LOCAL(env, self);
            self = PTR_AS(YogNameFrame, CUR_FRAME)->self;

            PUSH(self);
            POP_LOCALS(env);
            break;
        }
    case OP(RET):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            POP_FRAME();
            PC = SCRIPT_FRAME(CUR_FRAME)->pc;

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(STORE_NONLOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t level = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            YogVal* ptr = get_outer_vars_ptr(env, level, index);
            *ptr = val;

            POP_LOCALS(env);
            break;
        }
    case OP(LOAD_NONLOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t level = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            YogVal* ptr = get_outer_vars_ptr(env, level, index);
            val = *ptr;

            PUSH(val);
            POP_LOCALS(env);
            break;
        }
    case OP(STORE_GLOBAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID name = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            YogVal globals = SCRIPT_FRAME(CUR_FRAME)->globals;
            YogTable_insert(env, globals, ID2VAL(name), val);

            POP_LOCALS(env);
            break;
        }
    case OP(LOAD_ATTR):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID name = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal obj = YUNDEF;
            PUSH_LOCAL(env, obj);
            obj = POP();
            YogVal klass = YUNDEF;
            PUSH_LOCAL(env, klass);
        
            klass = YogVal_get_klass(env, obj);
            GetAttrExecutor exec = PTR_AS(YogKlass, klass)->exec_get_attr;
            if (exec == NULL) {
                exec = exec_get_attr;
            }
        
            exec(env, obj, name);
        
            POP_LOCALS(env);

            POP_LOCALS(env);
            break;
        }
    case OP(MAKE_ARRAY):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t size = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal array = YUNDEF;
            PUSH_LOCAL(env, array);
            array = YogArray_of_size(env, size);
            uint_t i;
            for (i = 0; i < size; i++) {
                YogVal body = PTR_AS(YogArray, array)->body;
                PTR_AS(YogValArray, body)->items[size - i - 1] = POP();
            }
            PTR_AS(YogArray, array)->size = size;

            PUSH(array);
            POP_LOCALS(env);
            break;
        }
    case OP(MAKE_DICT):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t size = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal dict = YUNDEF;
            PUSH_LOCAL(env, dict);
            YogVal key = YUNDEF;
            YogVal value = YUNDEF;
            PUSH_LOCALS2(env, key, value);
        
            dict = YogDict_new(env);
            uint_t i;
            for (i = 0; i < size; i++) {
                value = POP();
                key = POP();
                YogDict_set(env, dict, key, value);
            }
        
            POP_LOCALS(env);

            PUSH(dict);
            POP_LOCALS(env);
            break;
        }
    case OP(MAKE_SET):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t size = *((uint8_t*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(uint8_t);
            YogVal set = YUNDEF;
            PUSH_LOCAL(env, set);
            YogVal elem = YUNDEF;
            PUSH_LOCAL(env, elem);
        
            set = YogSet_new(env);
            uint_t i;
            for (i = 0; i < size; i++) {
                elem = POP();
                YogSet_add(env, set, elem);
            }
        
            POP_LOCALS(env);

            PUSH(set);
            POP_LOCALS(env);
            break;
        }
    case OP(FINISH):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            POP_JMPBUF(env);
            POP_FRAME();
            RETURN(env, val);

            POP_LOCALS(env);
            break;
        }
    case OP(PRINT_TOP):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(env, val);
            val = POP();
            YogVal s = YogEval_call_method(env, val, "to_s", 0, NULL);
            YOG_ASSERT(env, IS_OBJ_OF(env, s, cString), "object isn't string");
            printf("=> %s\n", STRING_CSTR(s));

            POP_LOCALS(env);
            break;
        }
    case OP(STORE_ATTR):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID name = *((ID*)&PTR_AS(YogByteArray, CODE->insts)->items[PC]);
            PC += sizeof(ID);
            YogVal obj = YUNDEF;
            YogVal val = YUNDEF;
            PUSH_LOCALS2(env, obj, val);
            obj = POP();
            val = POP();
            YogVal attr = YUNDEF;
            YogVal klass_of_obj = YUNDEF;
            YogVal klass_of_attr = YUNDEF;
            PUSH_LOCALS3(env, attr, klass_of_obj, klass_of_attr);
        
            klass_of_obj = YogVal_get_klass(env, obj);
            BOOL has_attrs;
            if (IS_PTR(obj) && ((PTR_AS(YogBasicObj, obj)->flags & HAS_ATTRS) != 0)) {
                has_attrs = TRUE;
            }
            else {
                has_attrs = FALSE;
            }
        
            if (has_attrs) {
                attr = YogObj_get_attr(env, obj, name);
            }
            if (IS_UNDEF(attr)) {
                attr = YogObj_get_attr(env, klass_of_obj, name);
            }
            if (!IS_UNDEF(attr)) {
                klass_of_attr = YogVal_get_klass(env, attr);
                void (*exec)(YogEnv*, YogVal, YogVal, YogVal) = PTR_AS(YogKlass, klass_of_attr)->exec_set_descr;
                if (exec != NULL) {
                    exec(env, attr, obj, val);
                }
                else if (has_attrs) {
                    YogObj_set_attr_id(env, obj, name, val);
                }
                else {
                    ID id = PTR_AS(YogKlass, klass_of_obj)->name;
                    const char* klass_name = YogVM_id2name(env, env->vm, id);
                    YogError_raise_AttributeError(env, "can't set attribute to '%s' object", klass_name);
                }
            }
            else if (has_attrs) {
                YogObj_set_attr_id(env, obj, name, val);
            }
            else {
                ID id = PTR_AS(YogKlass, klass_of_obj)->name;
                YogVM* vm = env->vm;
                const char* klass_name = YogVM_id2name(env, vm, id);
                const char* attr_name = YogVM_id2name(env, vm, name);
                YogError_raise_AttributeError(env, "%s object has no attribute '%s'", klass_name, attr_name);
            }
        
            POP_LOCALS(env);

            POP_LOCALS(env);
            break;
        }
    case OP(NOT):
        {
            YogVal val = YUNDEF;
            YogVal b = YUNDEF;
            PUSH_LOCALS2(env, val, b);
            val = POP();
            if (YOG_TEST(val)) {
                b = YFALSE;
            }
            else {
                b = YTRUE;
            }

            PUSH(b);
            POP_LOCALS(env);
            break;
        }
/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
