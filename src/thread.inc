/**
 * This file was generated by "tools/inst.py src/insts.def" automatically.
 * DO NOT TOUCH!!
 */

#line 6 "src/thread.inc"
    case OP(LOAD_SPECIAL):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YogVal_nil();
#line 18 "src/insts.def"

#line 14 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 18 "src/thread.inc"
    case OP(POP):
        {
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "stack depth is zero.");
            POP();
#line 25 "src/insts.def"

#line 24 "src/thread.inc"
            break;
        }
#line 27 "src/thread.inc"
    case OP(PUSH_CONST):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YogVal_nil();
#line 32 "src/insts.def"
            val = CONSTS(index);

#line 36 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 40 "src/thread.inc"
    case OP(CALL_METHOD):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID method = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 40 "src/insts.def"
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
        
            YogVal receiver = POP();
            YogVal attr = YogVal_get_attr(ENV, receiver, method);
            call_method(ENV, THREAD, receiver, attr, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);

#line 67 "src/thread.inc"
            break;
        }
#line 70 "src/thread.inc"
    case OP(STORE_PKG):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "stack depth is zero.");
            YogVal val = POP();
#line 52 "src/insts.def"
            YogVal key = YogVal_symbol(id);
            YogTable_insert(ENV, PKG_VARS(CUR_FRAME), key, val);

#line 81 "src/thread.inc"
            break;
        }
#line 84 "src/thread.inc"
    case OP(STORE_LOCAL):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "stack depth is zero.");
            YogVal val = POP();
#line 61 "src/insts.def"
            LOCAL_VARS(CUR_FRAME)->items[index] = val;

#line 94 "src/thread.inc"
            break;
        }
#line 97 "src/thread.inc"
    case OP(CALL_COMMAND):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID command = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 69 "src/insts.def"
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
        
            YogVal val = lookup_builtins(ENV, command);
            YogVal unbound_self = YogVal_undef();
            call_method(ENV, THREAD, unbound_self, val, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);

#line 124 "src/thread.inc"
            break;
        }
#line 127 "src/thread.inc"
    case OP(MAKE_PACKAGE_METHOD):
        {
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "stack depth is zero.");
            YogVal code = POP();
            YogVal method = YogVal_nil();
#line 81 "src/insts.def"
            YogBoundMethod* m = YogBoundMethod_new(ENV);
            m->self = YogVal_obj(YOGBASICOBJ(PKG_FRAME(CUR_FRAME)->pkg));
            m->code = YOGVAL_PTR(code);
        
            method = YogVal_obj(YOGBASICOBJ(m));

#line 139 "src/thread.inc"
            PUSH(method);
            break;
        }
#line 143 "src/thread.inc"
    case OP(CALL_FUNCTION):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 93 "src/insts.def"
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
        
            YogVal callee = POP();
            YogVal unbound_self = YogVal_undef();
            call_method(ENV, THREAD, unbound_self, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);

#line 167 "src/thread.inc"
            break;
        }
#line 170 "src/thread.inc"
    case OP(LOAD_PKG):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YogVal_nil();
#line 105 "src/insts.def"
            YogVal key = YogVal_symbol(id);
            if (!YogTable_lookup(ENV, PKG_VARS(CUR_FRAME), key, &val)) {
                val = lookup_builtins(ENV, id);
                Yog_assert(ENV, !IS_UNDEF(val), "Can't find package var.");
            }

#line 183 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 187 "src/thread.inc"
    case OP(LOAD_LOCAL):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YogVal_nil();
#line 117 "src/insts.def"
            val = LOCAL_VARS(CUR_FRAME)->items[index];

#line 196 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 200 "src/thread.inc"
    case OP(JUMP):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&CODE->insts->items[PC]);
            PC += sizeof(pc_t);
#line 125 "src/insts.def"
            JUMP(dest);

#line 208 "src/thread.inc"
            break;
        }
#line 211 "src/thread.inc"
    case OP(JUMP_IF_FALSE):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&CODE->insts->items[PC]);
            PC += sizeof(pc_t);
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "stack depth is zero.");
            YogVal val = POP();
#line 133 "src/insts.def"
            YogValType type = YOGVAL_TYPE(val);
            if ((type == VAL_NIL) || ((type == VAL_BOOL) && !YOGVAL_BOOL(val))) {
                JUMP(dest);
            }

#line 224 "src/thread.inc"
            break;
        }
#line 227 "src/thread.inc"
    case OP(DUP):
        {
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "stack depth is zero.");
            YogVal val = POP();
#line 144 "src/insts.def"

#line 233 "src/thread.inc"
            PUSH(val);
            PUSH(val);
            break;
        }
/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
