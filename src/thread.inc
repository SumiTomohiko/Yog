/**
 * This file was generated by "tools/inst.py src/insts.def" automatically.
 * DO NOT TOUCH!!
 */

#line 6 "src/thread.inc"
    case OP(LOAD_SPECIAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
#line 18 "src/insts.def"

#line 15 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 20 "src/thread.inc"
    case OP(POP):
        {
            POP();
#line 25 "src/insts.def"

#line 25 "src/thread.inc"
            break;
        }
#line 28 "src/thread.inc"
    case OP(PUSH_CONST):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
#line 32 "src/insts.def"
            val = CONSTS(index);

#line 38 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 43 "src/thread.inc"
    case OP(MAKE_STRING):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
#line 40 "src/insts.def"
            YogVal c = CONSTS(index);
            val = YogString_clone(ENV, c);

#line 54 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 59 "src/thread.inc"
    case OP(CALL_METHOD):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID method = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 49 "src/insts.def"
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
        
            YogVal receiver = POP();
            YogVal attr = YogVal_get_attr(ENV, receiver, method);
            call_method(ENV, THREAD, receiver, attr, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
        
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);

#line 90 "src/thread.inc"
            break;
        }
#line 93 "src/thread.inc"
    case OP(STORE_NAME):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
#line 65 "src/insts.def"
            YogVal key = ID2VAL(id);
            YogTable* vars = NAME_VARS(CUR_FRAME);
            YogTable_insert(ENV, PTR2VAL(vars), key, val);

#line 106 "src/thread.inc"
            POP_LOCALS(ENV);
            break;
        }
#line 110 "src/thread.inc"
    case OP(STORE_LOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
#line 75 "src/insts.def"
            LOCAL_VARS(CUR_FRAME)->items[index] = val;

#line 121 "src/thread.inc"
            POP_LOCALS(ENV);
            break;
        }
#line 125 "src/thread.inc"
    case OP(CALL_COMMAND):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID command = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 83 "src/insts.def"
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
        
            YogVal callee = YUNDEF;
            if (!lookup_frame_vars(ENV, CUR_FRAME, command, &callee)) {
                callee = lookup_builtins(ENV, command);
            }
        
            YogVal unbound_self = YUNDEF;
            call_method(ENV, THREAD, unbound_self, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
        
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);

#line 160 "src/thread.inc"
            break;
        }
#line 163 "src/thread.inc"
    case OP(MAKE_PACKAGE_METHOD):
        {
            YogVal code = YUNDEF;
            YogVal method = YUNDEF;
            PUSH_LOCALS2(ENV, code, method);
            code = POP();
#line 103 "src/insts.def"
            method = YogBoundMethod_new(ENV);
            setup_script_method(ENV, method, code);
            YogVal self = PTR_AS(YogNameFrame, CUR_FRAME)->self;
            OBJ_AS(YogBoundMethod, method)->self = self;

#line 175 "src/thread.inc"
            PUSH(method);
            POP_LOCALS(ENV);
            break;
        }
#line 180 "src/thread.inc"
    case OP(CALL_FUNCTION):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t kwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t blockargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t varkwargc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 114 "src/insts.def"
            POP_ARGS(args, kwargs, blockarg, vararg, varkwarg);
        
            YogVal callee = POP();
            YogVal unbound_self = YUNDEF;
            call_method(ENV, THREAD, unbound_self, callee, argc, args, blockarg, kwargc, kwargs, vararg, varkwarg);
        
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);
            POP_LOCALS(ENV);

#line 208 "src/thread.inc"
            break;
        }
#line 211 "src/thread.inc"
    case OP(LOAD_GLOBAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
#line 130 "src/insts.def"
            YogTable* globals = SCRIPT_FRAME(CUR_FRAME)->globals;
            if (!YogTable_lookup(ENV, PTR2VAL(globals), ID2VAL(id), &val)) {
                val = lookup_builtins(ENV, id);
            }
            YOG_ASSERT(ENV, !IS_UNDEF(val), "can't find global variable");

#line 225 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 230 "src/thread.inc"
    case OP(LOAD_NAME):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
#line 142 "src/insts.def"
            YogVal key = ID2VAL(id);
            if (!YogTable_lookup(ENV, PTR2VAL(NAME_VARS(CUR_FRAME)), key, &val)) {
                val = lookup_builtins(ENV, id);
                YOG_ASSERT(ENV, !IS_UNDEF(val), "Can't find package var.");
            }

#line 244 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 249 "src/thread.inc"
    case OP(LOAD_LOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
#line 154 "src/insts.def"
            val = LOCAL_VARS(CUR_FRAME)->items[index];

#line 259 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 264 "src/thread.inc"
    case OP(JUMP):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&CODE->insts->items[PC]);
            PC += sizeof(pc_t);
#line 162 "src/insts.def"
            JUMP(dest);

#line 272 "src/thread.inc"
            break;
        }
#line 275 "src/thread.inc"
    case OP(JUMP_IF_FALSE):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            pc_t dest = *((pc_t*)&CODE->insts->items[PC]);
            PC += sizeof(pc_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
#line 170 "src/insts.def"
            YogValType type = VAL_TYPE(val);
            if ((type == VAL_NIL) || ((type == VAL_BOOL) && !VAL2BOOL(val))) {
                JUMP(dest);
            }

#line 289 "src/thread.inc"
            POP_LOCALS(ENV);
            break;
        }
#line 293 "src/thread.inc"
    case OP(DUP):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
#line 181 "src/insts.def"

#line 300 "src/thread.inc"
            PUSH(val);
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 306 "src/thread.inc"
    case OP(MAKE_PACKAGE_BLOCK):
        {
            YogVal code = YUNDEF;
            YogVal block = YUNDEF;
            PUSH_LOCALS2(ENV, code, block);
            code = POP();
#line 188 "src/insts.def"
            block = YogPackageBlock_new(env);
            OBJ_AS(YogBasicBlock, block)->code = code;
            YogVal self = PTR_AS(YogNameFrame, CUR_FRAME)->self;
            OBJ_AS(YogPackageBlock, block)->self = self;
            YogTable* vars = PTR_AS(YogNameFrame, CUR_FRAME)->vars;
            OBJ_AS(YogPackageBlock, block)->vars = vars;

#line 320 "src/thread.inc"
            PUSH(block);
            POP_LOCALS(ENV);
            break;
        }
#line 325 "src/thread.inc"
    case OP(MAKE_BLOCK):
        {
            YogVal code = YUNDEF;
            YogVal block = YUNDEF;
            PUSH_LOCALS2(ENV, code, block);
            code = POP();
#line 201 "src/insts.def"
            block = YogBlock_new(ENV);
            OBJ_AS(YogBasicBlock, block)->code = code;
            OBJ_AS(YogBlock, block)->locals = PTR_AS(YogMethodFrame, CUR_FRAME)->vars;
            OBJ_AS(YogBlock, block)->outer_vars = SCRIPT_FRAME(CUR_FRAME)->outer_vars;
            OBJ_AS(YogBlock, block)->globals = SCRIPT_FRAME(CUR_FRAME)->globals;

#line 338 "src/thread.inc"
            PUSH(block);
            POP_LOCALS(ENV);
            break;
        }
#line 343 "src/thread.inc"
    case OP(MAKE_KLASS):
        {
            YogVal code = YUNDEF;
            YogVal super = YUNDEF;
            YogVal name = YUNDEF;
            PUSH_LOCALS3(ENV, code, super, name);
            code = POP();
            super = POP();
            name = POP();
#line 213 "src/insts.def"
            YogVal kls = YUNDEF;
            YogVal frame = YUNDEF;
            YogVal attrs = YUNDEF;
            PUSH_LOCALS3(ENV, kls, frame, attrs);
        
            kls = YogKlass_new(ENV, NULL, super);
            OBJ_AS(YogKlass, kls)->name = VAL2ID(name);
            OBJ_AS(YogObj, kls)->attrs = YUNDEF;
            attrs = YogTable_new_symbol_table(ENV);
            OBJ_AS(YogObj, kls)->attrs = attrs;
        
            frame = YogKlassFrame_new(ENV);
            setup_script_frame(ENV, frame, code);
            PTR_AS(YogNameFrame, frame)->self = kls;
            PTR_AS(YogNameFrame, frame)->vars = PTR_AS(YogTable, attrs);
        
            PUSH_FRAME(frame);
        
            POP_LOCALS(ENV);

#line 373 "src/thread.inc"
            POP_LOCALS(ENV);
            break;
        }
#line 377 "src/thread.inc"
    case OP(MAKE_METHOD):
        {
            YogVal code = YUNDEF;
            YogVal method = YUNDEF;
            PUSH_LOCALS2(ENV, code, method);
            code = POP();
#line 239 "src/insts.def"
            method = YogUnboundMethod_new(ENV);
            setup_script_method(ENV, method, code);

#line 387 "src/thread.inc"
            PUSH(method);
            POP_LOCALS(ENV);
            break;
        }
#line 392 "src/thread.inc"
    case OP(PUSH_SELF_NAME):
        {
            YogVal self = YUNDEF;
            PUSH_LOCAL(ENV, self);
#line 248 "src/insts.def"
            self = PTR_AS(YogNameFrame, CUR_FRAME)->self;

#line 399 "src/thread.inc"
            PUSH(self);
            POP_LOCALS(ENV);
            break;
        }
#line 404 "src/thread.inc"
    case OP(RET):
        {
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
#line 256 "src/insts.def"
            POP_FRAME();
            if (PTR_AS(YogFrame, CUR_FRAME)->type == FRAME_C) {
                return val;
            }
        
            PC = SCRIPT_FRAME(CUR_FRAME)->pc;

#line 417 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 422 "src/thread.inc"
    case OP(STORE_NONLOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t level = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
#line 269 "src/insts.def"
            /* TODO */

#line 435 "src/thread.inc"
            PUSH(val);
            POP_LOCALS(ENV);
            break;
        }
#line 440 "src/thread.inc"
    case OP(LOAD_NONLOCAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t level = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
#line 277 "src/insts.def"
            /* TODO */

#line 454 "src/thread.inc"
            POP_LOCALS(ENV);
            break;
        }
#line 458 "src/thread.inc"
    case OP(STORE_GLOBAL):
        {
            YOG_ASSERT(env, PC < YogByteArray_size(env, CODE->insts), "pc is over code length.");
            ID name = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YUNDEF;
            PUSH_LOCAL(ENV, val);
            val = POP();
#line 285 "src/insts.def"
            YogTable* globals = SCRIPT_FRAME(CUR_FRAME)->globals;
            YogTable_insert(ENV, PTR2VAL(globals), ID2VAL(name), val);

#line 470 "src/thread.inc"
            POP_LOCALS(ENV);
            break;
        }
/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
