/**
 * This file was generated by "tools/inst.py src/insts.def" automatically.
 * DO NOT TOUCH!!
 */

#line 6 "src/thread.inc"
    case OP(LOAD_SPECIAL):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YogVal_nil();
#line 18 "src/insts.def"

#line 14 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 18 "src/thread.inc"
    case OP(PUSH_CONST):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YogVal_nil();
#line 25 "src/insts.def"
            val = CONSTS(index);

#line 27 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 31 "src/thread.inc"
    case OP(CALL_METHOD):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            ID method = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 33 "src/insts.def"
            YogVal args[argc];
            unsigned int i = 0;
            for (i = 0; i < argc; i++) {
                args[i] = POP();
            }
            YogVal receiver = POP();
            YogVal ret = YogThread_call_method_id(ENV, receiver, method, argc, args);
            PUSH(ret);

#line 49 "src/thread.inc"
            break;
        }
#line 52 "src/thread.inc"
    case OP(STORE_PKG):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "");
            YogVal val = POP();
#line 48 "src/insts.def"
            YogVal key = YogVal_symbol(id);
            YogTable_insert(ENV, PKG_VARS(FRAME), key, val);

#line 63 "src/thread.inc"
            break;
        }
#line 66 "src/thread.inc"
    case OP(STORE_LOCAL):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "");
            YogVal val = POP();
#line 57 "src/insts.def"
            LOCAL_VARS(FRAME)->items[index] = val;

#line 76 "src/thread.inc"
            break;
        }
#line 79 "src/thread.inc"
    case OP(CALL_COMMAND):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            ID command = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 65 "src/insts.def"
            YogVal args[argc];
            unsigned int i = 0;
            for (i = 0; i < argc; i++) {
                args[i] = POP();
            }
            YogThread_call_command(ENV, command, argc, args);

#line 95 "src/thread.inc"
            break;
        }
#line 98 "src/thread.inc"
    case OP(MAKE_FUNC):
        {
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "");
            YogVal code = POP();
            YogVal func = YogVal_nil();
#line 78 "src/insts.def"
            YogGCObj* gcobj = YOGVAL_GCOBJ(code);
            Yog_assert(ENV, gcobj->type == GCOBJ_CODE, "Object isn't YogCode.");
            YogCode* c = (YogCode*)gcobj;
        
            YogFunc* f = YogFunc_new(ENV);
            f->code = c;
            func = YogVal_gcobj(YOGGCOBJ(f));

#line 112 "src/thread.inc"
            PUSH(func);
            break;
        }
#line 116 "src/thread.inc"
    case OP(CALL_FUNC):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            uint8_t argc = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
#line 92 "src/insts.def"
            YogVal args[argc];
            unsigned int i = 0;
            for (i = 0; i < argc; i++) {
                args[i] = POP();
            }
        
            YogVal callee = POP();
            YogGCObj* gcobj = YOGVAL_GCOBJ(callee);
            Yog_assert(ENV, gcobj->type == GCOBJ_FUNC, "Callee isn't function.");
            YogFunc* func = (YogFunc*)gcobj;
            YogCode* new_code = func->code;
            Yog_assert(ENV, new_code->argc == argc, "Arguments count miss match.");
        
            YogFrame* new_frame = YogFrame_new(ENV);
            LOCAL_VARS(new_frame) = YogValArray_new(ENV, new_code->local_vars_count);
            for (i = 0; i < argc; i++) {
                LOCAL_VARS(new_frame)->items[i] = args[i];
            }
            new_frame->stack = YogValArray_new(ENV, new_code->stack_size);
            FRAME = new_frame;
            PC = 0;
            CODE = new_code;

#line 145 "src/thread.inc"
            break;
        }
#line 148 "src/thread.inc"
    case OP(LOAD_PKG):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            ID id = *((ID*)&CODE->insts->items[PC]);
            PC += sizeof(ID);
            YogVal val = YogVal_nil();
#line 121 "src/insts.def"
            YogVal key = YogVal_symbol(id);
            if (!YogTable_lookup(ENV, PKG_VARS(FRAME), key, &val)) {
                Yog_assert(ENV, FALSE, "Can't find package var.");
            }

#line 160 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 164 "src/thread.inc"
    case OP(LOAD_LOCAL):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            uint8_t index = *((uint8_t*)&CODE->insts->items[PC]);
            PC += sizeof(uint8_t);
            YogVal val = YogVal_nil();
#line 132 "src/insts.def"
            val = LOCAL_VARS(FRAME)->items[index];

#line 173 "src/thread.inc"
            PUSH(val);
            break;
        }
#line 177 "src/thread.inc"
    case OP(JUMP):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            pc_t dest = *((pc_t*)&CODE->insts->items[PC]);
            PC += sizeof(pc_t);
#line 140 "src/insts.def"
            PC = dest;

#line 185 "src/thread.inc"
            break;
        }
#line 188 "src/thread.inc"
    case OP(JUMP_IF_FALSE):
        {
            Yog_assert(env, PC < YogByteArray_size(env, CODE->insts), "");
            pc_t dest = *((pc_t*)&CODE->insts->items[PC]);
            PC += sizeof(pc_t);
            Yog_assert(env, 0 < YogValArray_size(env, STACK), "");
            YogVal val = POP();
#line 148 "src/insts.def"
            YogValType type = YOGVAL_TYPE(val);
            if ((type == VAL_NIL) || ((type == VAL_BOOL) && !YOGVAL_BOOL(val))) {
                PC = dest;
            }

#line 201 "src/thread.inc"
            break;
        }
/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=c
 */
