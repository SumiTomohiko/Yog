
= +builtins+ package

You can use classes/modules/functions/objects in this package without the +import+ statement.

== Built-in Classes

class: Array
  base: Object

  You can make arrays with square brackets (+[]+) and commas (+,+) to separate values. For example, +[42, 26]+ is an array which has +42+ as first element and +26+ as second element.

  Each elements in arrays are accessed by an index enclosing square brackets. Index of the first element is zero. If negative index +idx+ is given to an array +a+, it is treated as +a.size \+ idx+, so the last element is accessed with +a[-1]+.

  method: +(a)
    parameters:
      a: An array
    return: New array
    exceptions:
      TypeError: When _a_ is not an array.

    Concatenates two arrays.

  method: <<(obj)
    parameters:
      obj: an object
    return: +self+

    Adds +obj+ to the array.

  method: [](index)
    parameters:
      index: element's index starting zero
    return: the object at _index_th
    exceptions:
      IndexError: _index_ is out of range.
      TypeError: _index_ isn't Fixnum.

    Returns the _index_th object.

  method: []=(index, value)
    parameters:
      index: element's index starting zero
    return: +self+
    exceptions:
      IndexError: _index_ is out of range.
      TypeError: _index_ isn't Fixnum.

    Sets the _index_th object.

  method: each(&block)
    parameters:
      block: code to execute in each iterations
    return: +self+
    block: block(elem)

    Execute _block_ for each elements in an array. This method gives each elements as an argument to _block_.

  property: empty?
    type: Bool

    Becomes +true+ when no objects are in an array.

  method: get(index, default=nil)
    parameters:
      index: element's index starting zero. Negative value is allowed.
      default: return value when _index_ is out of range
    return: the object at _index_th

    Returns the _index_th object. When _index_ is out of range, returns _default_.

  method: include?(obj)
    parameters:
      obj: an object
    return: +true+ or +false+

    Check if _obj_ is in an array.

  method: join(sep)
    parameters:
      sep: a separator between elements
    return: string

    Concatenates elements in an array separating with _sep_. Each elements are converted to +String+ with the +to_s()+ method.

  method: pop()
    return: a poped value
    exceptions:
      IndexError: the array is empty

    Removes one element from an array.

  method: push(obj)
    parameters:
      obj: a pushed object
    return: +self+

    Appends one object to the tail of an array.

  method: shift()
    return: an object which was at head of an array
    exceptions:
      IndexError: an array is empty

    Removes one object from the head of an array.

  method: slice(pos, len=nil)
    parameters:
      pos: index of a first element. Negative value is allowed.
      len: length
    return: a new array

    Makes a new array with elements which are from _pos_ to _pos_ +\++ _len_ +- 1+. When _pos_ is out of range, an empty array (+[]+) is returned.

  property: size
    type: Fixnum
    Objects number in the array.

  method: to_s()
    return: string representation of an array

    Converts an array into +String+.

  method: unshift(obj)
    parameters:
      obj: any object
    return: +self+

    Add _obj_ to a head of an array.

class: AttributeError
  base: Exception

  The exception to represent failures in getting/setting attributes.

class: Bignum
  base: Object
  including: Comparable

  method: %(n)
    parameters:
      n: Fixnum or Bignum
    return: +self % n+
    exceptions:
      TypeError: _n_ is not Fixnum nor Bignum

  method: &(n)
    parameters:
      n: Fixnum or Bignum
    return: bitwise and of +self+ and _n_
    exceptions:
      TypeError: _n_ is not Fixnum nor Bignum

  method: *(n)
    parameters:
      n: Fixnum , Bignum or Float
    return: +self *+ _n_
    exceptions:
      TypeError: _n_ is not Fixnum, Bignum nor Float

  method: **(n)
    parameters:
      n: Fixnum or Float
    return: +self **+ _n_
    exceptions:
      TypeError: _n_ is not Fixnum nor Float

  method: +(n)
    parameters:
      n: Fixnum, Bignum or Float
    return: +self \++ _n_
    exceptions:
      TypeError: _n_ is not Fixnum, Bignum nor Float

  method: +self()
    return: +self+

  method: -(n)
    parameters:
      n: Fixnum, Bignum or Float
    return: +self -+ _n_
    exceptions:
      TypeError: _n_ is not Fixnum, Bignum nor Float

  method: -self()
    return: negated +self+

  method: /(n)
    parameters:
      n: Fixnum, Bignum or Float
    return: +self /+ _n_. Always Float.
    exceptions:
      TypeError: _n_ is not Fixnum, Bignum nor Float
      ZeroDivisionError: _n_ is zero or 0.0

  method: //(n)
    parameters:
      n: Fixnum, Bignum or Float
    return: +self //+ _n_
    exceptions:
      TypeError: _n_ is not Fixnum, Bignum nor Float
      ZeroDivisionError: _n_ is zero or 0.0

  method: <<(n)
    parameters:
      n: Fixnum
    return: +self+ left-shifted by _n_
    exceptions:
      TypeError: _n_ is not Fixnum

  method: <=>(n)
    parameters:
      n: Bignum
    return: +-1+ when +self <+ _n_, +1+ when +self >+ _n_ and zero when +self ==+ _n_
    exceptions:
      TypeError: _n_ is not Bignum

  method: >>(n)
    parameters:
      n: Fixnum
    return: +self+ right-shifted by _n_
    exceptions:
      TypeError: _n_ is not Fixnum

  method: ^(n)
    parameters:
      n: Fixnum or Bignum
    return: bitwise exclusive or of +self+ and _n_
    exceptions:
      TypeError: _n_ is not Fixnum nor Bignum

  method: hash()
    return: hash

  method: to_s()
    return: string representation of a Bignum

    Converts a Bignum into +String+.

  method: |(n)
    parameters:
      n: Fixnum or Bignum
    return: bitwise or of +self+ and _n_
    exceptions:
      TypeError: _n_ is not Fixnum nor Bignum

  method: ~self()
    return: not +self+

class: Bool
  base: Object

  The class of +true+ and +false+.

  method: hash()

  method: to_s()
    return: string representation of +Bool+

    Converts +Bool+ into +String+.

class: Coroutine
  base: Object

  A coroutine is a suspendable function. A coroutine can stop executing a routine, and can restart later.

  To create a coroutine, use the +Coroutine+ constructor giving a block. This block is a coroutine's body.

    co = Coroutine.new() do
      print(42)
    end

  A coroutine doesn't start automatically when created. Call +Coroutine#resume+ to start.

    co.resume()   # prints 42

  Arguments to +Coroutine#resume+ become actual parameters of a block. +Coroutine#resume+ accepts any number of arguments.

    co = Coroutine.new() do [n]
      print(n)
    end
    co.resume(42) # prints 42

  A coroutine stops executing with +Coroutine.yield+.

    co = Coroutine.new() do
      42.times() do [n]
        print(n)
        Coroutine.yield()
      end
    end
    co.resume()   # prints 0

  Calling +Coroutine#resume+ for this coroutine again restarts executing until next +Coroutine.yield+ is called or the block ends.

    co.resume()   # prints 1
    co.resume()   # prints 2
    co.resume()   # prints 3
    ...(snip)...
    co.resume()   # prints 41
    co.resume()   # prints nothing

  Resuming an ended coroutine raises +CoroutineError+ (dead coroutine called).

  (Coroutines which needs different methods to resume/suspend like above is called asymmetric coroutines)

  +Coroutine#resume+ and +Coroutine.yield+ exchanges information. Arguments for +Coroutine.yield+ become return values of +Coroutine#resume+, arguments for +Coroutine#resume+ become return values of +Coroutine.yield+.

    co = Coroutine.new() do
      42.times() do [n]
        ping = Coroutine.yield("pong")
        puts(ping)
      end
    end
    co.resume()
    pong = co.resume("ping")  # prints "ping"
    puts(pong)                # prints "pong"

  Coroutine have status. They are +Coroutine.SUSPENDED+, +Coroutine.RUNNING+ or +Coroutine.DEAD+. When a coroutine is created, its status is +Coroutine.SUSPENDED+. Calling +Coroutine#resume+ makes its status to +Coroutine.RUNNING+. A +yield+ed coroutine's status is +Coroutine.SUSPENDED+. When a coroutine finishes, its status becomes +Coroutine.DEAD+. A coroutine's status is refered by +status+ property.

  property: dead?
    type: Bool

    Becomes +true+ when a coroutine's status is +Coroutine.DEAD+.

  method: init(&block)
    parameters:
      block: coroutine's body

    Constructor. _block_'s signature is any.

  method: resume(*args)
    parameters:
      args: actual arguments to a coroutine body or return values of +Coroutine.yield+
    return: actual arguments given to +Coroutine.yield+
    exceptions:
      CoroutineError: when a coroutine is dead

    Executes a coroutine.

  property: running?
    type: Bool

    Becomes +true+ when a coroutine's status is +Coroutine.RUNNING+.

  property: status
    type: Fixnum

    Status of a coroutine. +Coroutine.SUSPENDED+, +Coroutine.RUNNING+ or +Coroutine.DEAD+.

  property: suspended?
    type: Bool

    Becomes +true+ when a coroutine's status is +Coroutine.SUSPENDED+.

  classmethod: yield(*args)
    parameters:
      args: return values of +Coroutine#resume+
    return: actual parameters for +Coroutine#resume+

    Suspend a coroutine.

class: Dict
  base: Object

  method: +(d)
  method: [](key)
  method: []=(key, value)
  method: each(&block)
    Callback *block* for each pairs of key and value.
    The *block*'s signature is ``block(key, val)``.
  attribute: size
    type: Fixnum
    Number of entries in the dictionary.

class: Exception
  base: Object

  method: init(message=nil)
  attribute: message
  method: to_s()

class: File
  base: Object

  method: close()
  classmethod: open(path, mode, &block=nil)
    Callback *block* (if given).
    The *block*'s signature is ``block(fp)``.
    *fp* is a +File+ object.
    When *block* is given, +open+ closes the file at the end.
  method: read()
  method: readline()
  method: write(s)

class: Fixnum
  base: Object

  method: %(n)
  method: &(n)
  method: *(n)
  method: **(n)
  method: +(n)
  method: +self()
  method: -(n)
  method: -self()
  method: /(n)
  method: //(n)
  method: <<(n)
  method: <=>(n)
  method: >>(n)
  method: ^(n)
  method: hash()
  method: times(&block)
  method: to_s()
  method: |(n)
  method: ~self()

class: Object

  method: !=(obj)
  method: ==(obj)
  attribute: class
  method: get_attr(name)
  method: hash()
  method: inspect()
  method: to_s()

class: Set
  base: Object

  method: add(*args)
  method: include?(obj)
  attribute: size

class: Thread
  base: Object

  method: init(&block)
  method: run(arg)
  method: join()
  attribute: __recursive_stack__
    type: Array
    The Yog interpreter uses this attribute internally.
    `Nobody cares <http:://uncyclopedia.wikia.com/wiki/Nobody_cares>`_.

== Built-in Functions

function: __recurse__(obj, f, g)
  parameters:
    obj:
    f:
    g:
  return:

  The Yog interpreter uses this function internally.
  `Nobody cares <http:://uncyclopedia.wikia.com/wiki/Nobody_cares>`_.

function: bind(obj)
  parameters:
    obj: an object to bind
  return: a function which accepts a function to be bound

  Set +self+ in functions::

    o = Object.new()

    @bind(o)
    def foo()
      return self
    end

    foo() # => o

function: classmethod(function)
  parameters:
    f: function
  return: class method for *function*

  Return a class method for *function*.
  To declare class method, use this function in the decorator form::

    class Foo
      @classmethod
      def bar()
        # ...
      end
    end

function: get_current_thread()
  return: current thread

  Return the current thread.

  The Yog interpreter uses this function internally.

function: import_package(name)
  parameters:
    name: symbol of package name
  return: imported package

  Import a package.

  The Yog interpreter uses this function internally.
  If you want to import packages, use +import+ statement.

function: include(mod)
  parameters:
    mod: module to include
  return: which accepts a class to be included

  +include+ is used to mix-in a class and modules as a decorator::

    module Foo
      def bar()
        print(42)
      end
    end

    @include(Foo)
    class Baz
    end

  Calling ``Baz.new().bar()`` prints ``42``.

function: include_module(klass, mod)
  parameters:
    klass: class to include *module*
    module: included module
  return: +klass+

  Mix-in *module* to *klass*.

  The Yog interpreter uses this function internally.
  If you want to mix-in a class and modules, use +include+ function as a decorator.

function: loop(&block)
  parameters:
    &block: block to execute
  return: never return

  Execute *block* eternally.
  +loop+ passes a loop counter to *block*.

function: partial(f, \*args, \*\*kw)
  parameters:
    f: function to call
    args: arguments to *f*
    kw: arguments to *f*
  return: function

  +partial+ is a function for the partial application.
  A returned function accepts rest of arguments for *f*.
  This function is equivalent to this::

    def g(*v, **k)
      return f(*(args + v), **(kw + k))
    end

    return g

function: print(*args)
  parameters:
    args: objects to print standard output
  return: +nil+

  Print *args* to the standard output.
  If objects are not string, they are converted with +Object#to_s+.
  When no object are given, +print+ does nothing.

function: property(getter, setter=nil)
  parameters:
    getter: a function called on getting property
    setter: a function called on setting property
  return: a +Property+ object

  When a +Property+ object is gotten as an attribute, *getter* is called without arguments.
  If an attirubte to be set is a +Property+ object, *setter* is called with one argment.
  The *setter*'s argument is a new value of the attribute::

    class Foo
      def init()
        self.baz = 42
      end

      def get_bar()
        return self.baz
      end

      def set_bar(baz)
        self.baz = baz
      end

      bar = property(get_bar, set_bar)
    end

    foo = Foo.new()
    foo.bar # => 42
    foo.bar = 26
    foo.bar # => 26

function: puts(*args)
  parameters:
    args: objects to print standard output
  return: +nil+

  Print *args* to the standard output with trailing newlines.
  If objects are not string, they are converted with +Object#to_s+.
  When no object are given, +print+ prints one newline.

function: raise_exception(e)
  parameters:
    e: an exception
  return: +nil+. But this function never return!

  Raise an exception.

  The Yog interpreter uses this function internally.
  If you want to raise an exception, use the +raise+ statement.

== Built-in Objects

data: ARGV
  type: Array

  The +Array+ object containing command line parameters.
  +ARGV[0]+ is a script file name.

--
vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
