#!/usr/bin/env yog

from peg import action, pattern

class Token
  def init(lineno, value=nil)
    self.lineno = lineno
    self.value = value
  end
end

class Indent > Token
  def to_s()
    return "<Indent line {0}>".format(self.lineno)
  end
end

class Dedent > Token
  def to_s()
    return "<Dedent line {0}>".format(self.lineno)
  end
end

class Klass > Token
  def to_s()
    return "<Klass line {0}>".format(self.lineno)
  end
end

class Base > Token
  def to_s()
    return "<Base line {0}>".format(self.lineno)
  end
end

class Including > Token
  def to_s()
    return "<Including line {0}>".format(self.lineno)
  end
end

class Method > Token
  def to_s()
    return "<Method line {0}>".format(self.lineno)
  end
end

class Parameters > Token
  def to_s()
    return "<Parameters line {0}>".format(self.lineno)
  end
end

class Return > Token
  def to_s()
    return "<Return line {0}>".format(self.lineno)
  end
end

class Data > Token
  def to_s()
    return "<Data line {0}>".format(self.lineno)
  end
end

class Attribute > Token
  def to_s()
    return "<Attribute line {0}>".format(self.lineno)
  end
end

class Property > Token
  def to_s()
    return "<Property line {0}>".format(self.lineno)
  end
end

class Classmethod > Token
  def to_s()
    return "<Classmethod line {0}>".format(self.lineno)
  end
end

class Function > Token
  def to_s()
    return "<Function line {0}>".format(self.lineno)
  end
end

class Colon > Token
  def to_s()
    return "<Colon line {0}>".format(self.lineno)
  end
end

class Newline > Token
  def to_s()
    return "<Newline line {0}>".format(self.lineno)
  end
end

class Text > Token
  def to_s()
    return "<Text line {1}, {0}>".format(self.value.inspect(), self.lineno)
  end
end

KEY2TOKEN = {
  "class" => Klass,
  "base" => Base,
  "including" => Including,
  "method" => Method,
  "parameters" => Parameters,
  "return" => Return,
  "attribute" => Attribute,
  "classmethod" => Classmethod,
  "function" => Function,
  "property" => Property,
  "data" => Data }

class Lexer
  def init(fp)
    self.fp = fp
    self.lineno = 0
    self.margin_stack = [0]
    self.text_last? = false
  end

  def generate_indent_tokens(line)
    margin = (line =~ /\A\s*/).end(0)
    if self.margin_stack[-1] < margin
      if self.text_last?
        return []
      end
      self.margin_stack.push(margin)
      return [Indent.new(self.lineno)]
    end

    tokens = []
    while !self.margin_stack.empty?
      if self.margin_stack[-1] <= margin
        return tokens
      end
      self.margin_stack.pop()
      tokens << Dedent.new(self.lineno)
    end
  end

  def readline()
    comment_depth = 0
    while line = self.fp.readline()
      self.lineno += 1
      if line =~ /\A\s*--/
        comment_depth += 1
        next
      end
      if line =~ /\A\s*\+\+/
        comment_depth -= 1
        next
      end
      if 0 < comment_depth
        next
      end

      if line =~ /\A\s*#/
        next
      end
      if !self.text_last? && (line =~ /\A\s*\z/)
        next
      end
      break
    end
    return line
  end

  def split_key_value(line)
    size = line.size
    i = 0
    while i < size
      if line[i] == ":"
        i += 1
        if line[i] != ":"
          key = line.slice(0, i - 1).trim()
          value = line.slice(i).trim()
          return key, value
        end
      end
      i += 1
    end

    return nil, nil
  end

  def cut_margin(line)
    margin = self.margin_stack[-1]
    if line.size < margin
      return ""
    end
    return line.slice(margin)
  end

  def split_tokens(line)
    tokens = self.generate_indent_tokens(line)

    key, value = self.split_key_value(line)
    if key != nil
      tokens << KEY2TOKEN.get(key, Text).new(self.lineno, key)
      tokens << Colon.new(self.lineno)
      tokens << Text.new(self.lineno, value)
      tokens << Newline.new(self.lineno)
      self.text_last? = false
      return tokens
    end

    tokens << Text.new(self.lineno, self.cut_margin(line.gsub("::", ":")))
    self.text_last? = true
    return tokens
  end

  def get_tokens()
    tokens = []
    while line = self.readline()
      tokens += self.split_tokens(line)
    end
    tokens += self.generate_indent_tokens("")
    return tokens
  end
end

class Node
end

class TextNode > Node
end

class ClassNode > Node
  def init(name, base, including)
    self.name = name
    self.base = base
    self.including = including
    self.attrs = []
  end

  def to_s()
    return "<ClassNode {0}>".format(self.name)
  end
end

def token_pattern(klass)
  return pattern(klass) do [pat, act]
    next act.kind_of?(pat)
  end
end

klass_token = token_pattern(Klass)
colon_token = token_pattern(Colon)
text_token = token_pattern(Text)
newline_token = token_pattern(Newline)
indent_token = token_pattern(Indent)
dedent_token = token_pattern(Dedent)
base_token = token_pattern(Base)
including_token = token_pattern(Including)

text = action(text_token ^ 1) do [tokens]
  s = ""
  tokens.each() do [token]
    s << token.value
  end
  next s
end
base = action(base_token * colon_token * text_token * newline_token) do [ignore1, ignore2, text, ignore3]
  next text.value
end
including = action(including_token * colon_token * text_token * newline_token) do [ignore1, ignore2, text, ignore3]
  next text.value
end
klass_body = action(indent_token * (base ^ (-1)) * (including ^ (-1)) * (text ^ (-1)) * dedent_token) do [ignore1, base, including, text, ignore2]
  next [base.get(0), including.get(0), text.get(0, "")]
end
klass_body_opt = action(klass_body ^ (-1)) do [body]
  next body[0]
end
klass = action(klass_token * colon_token * text_token * newline_token * klass_body_opt) do [ignore1, ignore2, name, ignore3, body]
  next ClassNode.new(name.value, body[0], body[1])
end
grammar = (text / klass) ^ 0

class Parser
  def parse(fp)
    m = grammar.match(Lexer.new(fp).get_tokens())
    if m == nil
      raise SyntaxError.new("invalid tokens")
    end
    if !m.rest.empty?
      msg = "line {0}: invalid token: {1}".format(next_token.lineno, next_token)
      raise SyntaxError.new(msg)
    end
    return m.matched
  end
end

class HtmlGenerator
  def escape_html(s)
    t = ""
    s.each_char() do [c]
      tbl = { "<" => "&lt;", ">" => "&gt;", "&" => "&amp;", "\"" => "&quot;" }
      t << tbl.get(c, c)
    end
    return t
  end

  def conv_inline_markup(s)
    t = ""
    typewriter? = false
    s.each_char() do [c]
      nonlocal typewriter?
      if c == "+"
        if typewriter?
          t << "</tt>"
          typewriter? = false
        else
          t << "<tt>"
          typewriter? = true
        end
      else
        t << self.escape_html(c)
      end
    end
    return t
  end

  def write_class(fp, node)
    name = self.conv_inline_markup(node.name)
    base = self.conv_inline_markup(node.base)
    including = self.conv_inline_markup(node.including)
    fp.write(<<EOF.format(name, base, including))
<dl>
  <dt>class <tt>{0}</tt></dt>
  <dd>
    <table>
      <tbody>
        <tr>
          <th align="left">base class</th>
          <th align="center">:</th>
          <td><tt>{1}</tt></td>
        </tr>
        <tr>
          <th align="left">including module(s)</th>
          <th align="center">:</th>
          <td><tt>{2}</tt></td>
        </tr>
      </tbody>
    </table>
  </dd>
</dl>
EOF
  end

  def write_text(fp, s)
    fp.write(s)
  end

  def write_title(fp, level, title)
    fp.write(<<EOF.format(level + 1, self.conv_inline_markup(title)))
<h{0}>{1}</h{0}>
EOF
  end

  def start_pretty(fp)
    fp.write("<pre>")
  end

  def end_pretty(fp)
    fp.write("</pre>")
  end

  def write_pretty(fp, s)
    fp.write(self.escape_html(s))
  end

  def start_list(fp)
    fp.write("<ul>")
  end

  def end_list(fp)
    fp.write("</ul>")
  end

  def write_list_item(fp, s)
    fp.write("<li>{0}</li>".format(self.conv_inline_markup(s)))
  end

  def write_markup(fp, s)
    lines = s.split("\n")
    i = 0
    pretty? = false
    while i < lines.size
      line = lines[i]
      if m = (line =~ /\A(=+)/)
        self.write_title(fp, m.end() - 1, line.slice(m.end()).trim())
      elif m = (line =~ /\A\s+/)
        margin = m.end()

        self.start_pretty(fp)
        while i < lines.size
          line = lines[i]
          if !(line =~ /\A\s+/)
            break
          end
          self.write_pretty(fp, line.slice(margin) + "\n")
          i += 1
        end
        self.end_pretty(fp)
        next
      elif m = (line =~ /\A\+/)
        margin_stack = [0]

        self.start_list(fp)
        while i < lines.size
          line = lines[i]
          if m = (line =~ /\A(\s*\+)/)
            margin = m.end() - 1
            if margin_stack[-1] < margin
              margin_stack << margin
              self.start_list(fp)
            elif margin < margin_stack[-1]
              while 0 < j
                self.end_list(fp)
                margin_stack.pop()
                if margin_stack[-1] <= margin
                  break
                end
              end
            end
            self.write_list_item(fp, line.slice(m.end()))
          elif !(line =~ /\A[^\s]/)
            self.write_text(fp, line.trim() + "\n")
          else
            break
          end
          i += 1
        end
        while 0 < margin_stack.size
          margin_stack.pop()
          self.end_list(fp)
        end
        next
      else
        self.write_text(fp, line + "\n")
      end
      i += 1
    end
  end

  def start(fp)
    fp.write(<<EOF)
<html>
<body>
EOF
  end

  def end(fp)
    fp.write(<<EOF)
</body>
</html>
EOF
  end

  def write(fp, nodes)
    self.start(fp)
    nodes.each() do [node]
      if node.class == ClassNode
        self.write_class(fp, node)
      elif node.class == String
        self.write_markup(fp, node)
      else
        raise Exception.new("unknown node: {0}".format(node))
      end
    end
    self.end(fp)
  end
end

nodes = File.open(ARGV[1]) do [fp]
  next Parser.new().parse(fp)
end
File.open(ARGV[2], "w") do [fp]
  HtmlGenerator.new().write(fp, nodes)
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2 filetype=yog
