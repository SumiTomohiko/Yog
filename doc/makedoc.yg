#!/usr/bin/env yog

from peg import action, pattern

class Token
  def init(lineno, value=nil)
    self.lineno = lineno
    self.value = value
  end
end

class Indent > Token
  def to_s()
    return "<Indent line {0}>".format(self.lineno)
  end
end

class Dedent > Token
  def to_s()
    return "<Dedent line {0}>".format(self.lineno)
  end
end

class Klass > Token
  def to_s()
    return "<Klass line {0}>".format(self.lineno)
  end
end

class Base > Token
  def to_s()
    return "<Base line {0}>".format(self.lineno)
  end
end

class Including > Token
  def to_s()
    return "<Including line {0}>".format(self.lineno)
  end
end

class Method > Token
  def to_s()
    return "<Method line {0}>".format(self.lineno)
  end
end

class Parameters > Token
  def to_s()
    return "<Parameters line {0}>".format(self.lineno)
  end
end

class Return > Token
  def to_s()
    return "<Return line {0}>".format(self.lineno)
  end
end

class Data > Token
  def to_s()
    return "<Data line {0}>".format(self.lineno)
  end
end

class Attribute > Token
  def to_s()
    return "<Attribute line {0}>".format(self.lineno)
  end
end

class Property > Token
  def to_s()
    return "<Property line {0}>".format(self.lineno)
  end
end

class Classmethod > Token
  def to_s()
    return "<Classmethod line {0}>".format(self.lineno)
  end
end

class Function > Token
  def to_s()
    return "<Function line {0}>".format(self.lineno)
  end
end

class Colon > Token
  def to_s()
    return "<Colon line {0}>".format(self.lineno)
  end
end

class Newline > Token
  def to_s()
    return "<Newline line {0}>".format(self.lineno)
  end
end

class Text > Token
  def to_s()
    return "<Text line {1}, {0}>".format(self.value.inspect(), self.lineno)
  end
end

class Method > Token
end

class Return > Token
end

class Exceptions > Token
end

class Parameters > Token
end

KEY2TOKEN = {
  "class" => Klass,
  "base" => Base,
  "including" => Including,
  "method" => Method,
  "parameters" => Parameters,
  "return" => Return,
  "attribute" => Attribute,
  "classmethod" => Classmethod,
  "function" => Function,
  "property" => Property,
  "data" => Data,
  "return" => Return,
  "exceptions" => Exceptions }

class Lexer
  def init(fp)
    self.fp = fp
    self.lineno = 0
    self.margin_stack = [0]
    self.text_last? = false
  end

  def get_margin(line)
    return (line =~ /\A\s*/).end(0)
  end

  def generate_dedent_tokens(line)
    margin = self.get_margin(line)
    tokens = []
    while !self.margin_stack.empty?
      if self.margin_stack[-1] <= margin
        return tokens
      end
      self.margin_stack.pop()
      tokens << Dedent.new(self.lineno)
    end
  end

  def generate_indent_tokens(line)
    margin = self.get_margin(line)
    if self.margin_stack[-1] < margin
      if self.text_last?
        return []
      end
      self.margin_stack.push(margin)
      return [Indent.new(self.lineno)]
    end

    return self.generate_dedent_tokens(line)
  end

  def readline()
    comment_depth = 0
    while line = self.fp.readline()
      self.lineno += 1
      if line =~ /\A\s*--/
        comment_depth += 1
        next
      end
      if line =~ /\A\s*\+\+/
        comment_depth -= 1
        next
      end
      if 0 < comment_depth
        next
      end

      if line =~ /\A\s*#/
        next
      end
      if !self.text_last? && (line =~ /\A\s*\z/)
        next
      end
      break
    end
    return line
  end

  def split_key_value(line)
    size = line.size
    i = 0
    while i < size
      if line[i] == ":"
        i += 1
        if line[i] != ":"
          key = line.slice(0, i - 1).trim()
          value = line.slice(i).trim()
          return key, value
        end
      end
      i += 1
    end

    return nil, nil
  end

  def cut_margin(line)
    margin = self.margin_stack[-1]
    if line.size < margin
      return "\n"
    end
    return line.slice(margin)
  end

  def split_tokens(line)
    if self.text_last? && (line =~ /\A\s*\Z/)
      return [Text.new(self.lineno, self.cut_margin(line))]
    end
    tokens = self.generate_indent_tokens(line)

    key, value = self.split_key_value(line)
    if key != nil
      tokens << KEY2TOKEN.get(key, Text).new(self.lineno, key)
      tokens << Colon.new(self.lineno)
      tokens << Text.new(self.lineno, value)
      tokens << Newline.new(self.lineno)
      self.text_last? = false
      return tokens
    end

    tokens << Text.new(self.lineno, self.cut_margin(line.gsub("::", ":")))
    self.text_last? = true
    return tokens
  end

  def get_tokens()
    tokens = []
    while line = self.readline()
      tokens += self.split_tokens(line)
    end
    tokens += self.generate_dedent_tokens("")
    return tokens
  end
end

class Node
end

class TextNode > Node
end

class ClassNode > Node
  def init(name, base, including, desc, attrs)
    self.name = name
    self.base = base
    self.including = including
    self.desc = desc
    self.attrs = attrs
  end

  def to_s()
    return "<ClassNode {0}>".format(self.name)
  end
end

class AttributeNode > Node
  def init(name, desc)
    self.name = name
    self.desc = desc
  end
end

class PropertyNode > AttributeNode
end

class MethodNode > Node
  def init(sig, params, return_, excs, desc)
    self.sig = sig
    self.params = params
    self.return_ = return_
    self.excs = excs
    self.desc = desc
  end

  def to_s()
    return "<MethodNode {0}>".format(self.sig)
  end
end

class FunctionNode > MethodNode
end

class ClassmethodNode > MethodNode
end

class ParameterNode > Node
  def init(name, desc)
    self.name = name
    self.desc = desc
  end
end

class ExceptionNode > Node
  def init(type, desc)
    self.type = type
    self.desc = desc
  end
end

def token_pattern(klass)
  return pattern(klass) do [pat, act]
    next act.kind_of?(pat)
  end
end

klass_token = token_pattern(Klass)
colon_token = token_pattern(Colon)
text_token = token_pattern(Text)
newline_token = token_pattern(Newline)
indent_token = token_pattern(Indent)
dedent_token = token_pattern(Dedent)
base_token = token_pattern(Base)
including_token = token_pattern(Including)
method_token = token_pattern(Method)
function_token = token_pattern(Function)
classmethod_token = token_pattern(Classmethod)
parameters_token = token_pattern(Parameters)
return_token = token_pattern(Return)
exceptions_token = token_pattern(Exceptions)
property_token = token_pattern(Property)
attribute_token = token_pattern(Attribute)

text = action(text_token ^ 1) do [tokens]
  s = ""
  tokens.each() do [token]
    s << token.value
  end
  next s
end
base = action(base_token * colon_token * text_token * newline_token) do [ignore1, ignore2, text, ignore3]
  next text.value
end
including = action(including_token * colon_token * text_token * newline_token) do [ignore1, ignore2, text, ignore3]
  next text.value
end
exceptions_body = action(indent_token * ((text_token * colon_token * text_token * newline_token * ((indent_token * text * dedent_token) ^ (-1))) ^ 0) * dedent_token) do [ignore1, excs, ignore2]
  a = []
  excs.each() do [exc]
    a << ExceptionNode.new(exc[0].value, exc[2].value + exc[4].get(0, ""))
  end
  next a
end
exceptions = action(exceptions_token * colon_token * text_token * newline_token * exceptions_body) do [ignore1, ignore2, ignore3, ignore4, excs]
  next excs
end
return_ = action(return_token * colon_token * text_token * newline_token * ((indent_token * text * dedent_token) ^ (-1))) do [ignore1, ignore2, desc, ignore, desc2]
  s = desc.value + "\n"
  desc2.each() do [text]
    s << text[1]
  end
  next s
end
parameters_body = action(indent_token * ((text_token * colon_token * text_token * newline_token) ^ 0) * dedent_token) do [ignore1, params, ignore2]
  a = []
  params.each() do [param]
    a << ParameterNode.new(param[0].value, param[2].value)
  end
  next a
end
parameters = action(parameters_token * colon_token * text_token * newline_token * (parameters_body ^ (-1))) do [ignore1, ignore2, ignore3, ignore4, body]
  next body.get(0, [])
end
method_body = action(indent_token * (parameters ^ (-1)) * (return_ ^ (-1)) * (exceptions ^ (-1)) * (text ^ (-1)) * dedent_token) do [ignore1, params, return_, excs, desc, ignore2]
  next [params.get(0, []), return_.get(0), excs.get(0, []), desc.get(0)]
end
classmethod = action(classmethod_token * colon_token * text_token * newline_token * (method_body ^ (-1))) do [ignore1, ignore2, sig, ignore3, bodies]
  body = bodies.get(0, [[], "", [], ""])
  next ClassmethodNode.new(sig.value, body[0], body[1], body[2], body[3])
end
function = action(function_token * colon_token * text_token * newline_token * (method_body ^ (-1))) do [ignore1, ignore2, sig, ignore3, bodies]
  body = bodies.get(0, [[], "", [], ""])
  next FunctionNode.new(sig.value, body[0], body[1], body[2], body[3])
end
method = action(method_token * colon_token * text_token * newline_token * (method_body ^ (-1))) do [ignore1, ignore2, sig, ignore3, bodies]
  body = bodies.get(0, [[], "", [], ""])
  next MethodNode.new(sig.value, body[0], body[1], body[2], body[3])
end
attribute = action(attribute_token * colon_token * text_token * newline_token * ((indent_token * text * dedent_token) ^ (-1))) do [ignore1, ignore2, name, ignore3, desc]
  next AttributeNode.new(name.value, desc.get(0, []).get(1, ""))
end
prop = action(property_token * colon_token * text_token * newline_token * ((indent_token * text * dedent_token) ^ (-1))) do [ignore1, ignore2, name, ignore3, desc]
  next PropertyNode.new(name.value, desc.get(0, []).get(1, ""))
end
attr = action(prop / method / classmethod / attribute) do [attr]
  next attr
end
klass_body = action(indent_token * (base ^ (-1)) * (including ^ (-1)) * (text ^ (-1)) * (attr ^ 0) * dedent_token) do [ignore1, base, including, text, attrs, ignore2]
  next [base.get(0), including.get(0), text.get(0, ""), attrs]
end
klass_body_opt = action(klass_body ^ (-1)) do [body]
  next body.get(0, ["", "", "", []])
end
klass = action(klass_token * colon_token * text_token * newline_token * klass_body_opt) do [ignore1, ignore2, name, ignore3, body]
  next ClassNode.new(name.value, body[0], body[1], body[2], body[3])
end
grammar = (text / klass / function) ^ 0

class Parser
  def parse(fp)
    tokens = Lexer.new(fp).get_tokens()
    puts(tokens)
    m = grammar.match(tokens)
    if m == nil
      raise SyntaxError.new("invalid tokens")
    end
    if !m.rest.empty?
      next_token = m.rest[0]
      msg = "line {0}: invalid token: {1}".format(next_token.lineno, next_token)
      raise SyntaxError.new(msg)
    end
    return m.matched
  end
end

class HtmlGenerator
  def escape_html(s)
    t = ""
    s.each_char() do [c]
      tbl = { "<" => "&lt;", ">" => "&gt;", "&" => "&amp;", "\"" => "&quot;" }
      t << tbl.get(c, c)
    end
    return t
  end

  def conv_inline_markup(s)
    if s == nil
      return ""
    end

    t = ""
    typewriter? = false
    s.each_char() do [c]
      nonlocal typewriter?
      if c == "+"
        if typewriter?
          t << "</tt>"
          typewriter? = false
        else
          t << "<tt>"
          typewriter? = true
        end
      elif c == "\n"
        t << c << "<br/>\n"
      else
        t << self.escape_html(c)
      end
    end
    return t
  end

  def write_attribute(fp, attr, type)
    name = self.escape_html(attr.name)
    desc = self.conv_inline_markup(attr.desc)
    fp.write(<<EOF.format(type, name, desc))
<dl><dt>{0} <tt>{1}</tt></dt><dd><p>{2}</p></dd></dl>
EOF
  end

  def write_method(fp, meth, type)
    fp.write(<<EOF.format(type, meth.sig))
<dl>
  <dt>{0} <tt>{1}</tt></dt>
  <dd>
    <table><tbody>
      <tr>
        <th align="left">Parameter(s)</th>
        <th>:</th>
        <td>
          <table><tbody>
EOF
    meth.params.each() do [param]
      name = self.escape_html(param.name)
      desc = self.conv_inline_markup(param.desc)
      fp.write(<<EOF.format(name, desc))
            <tr><td><i>{0}</i></td><td>--</td><td>{1}</td></tr>
EOF
    end
    fp.write(<<EOF.format(self.conv_inline_markup(meth.return_)))
          </tbody</table>
        </td>
      </tr>
      <tr>
        <th align="left">Return</th>
        <th>:</th>
        <td>{0}</td>
      </tr>
      <tr>
        <th align="left">Exception(s)</th>
        <th>:</th>
        <td>
          <table><tbody>
EOF
    meth.excs.each() do [exc]
      type = self.escape_html(exc.type)
      desc = self.conv_inline_markup(exc.desc)
      fp.write(<<EOF.format(type, desc))
            <tr><td><tt>{0}</tt></td><td>--</td><td>{1}</td></tr>
EOF
    end
    fp.write(<<EOF.format(self.conv_inline_markup(meth.desc)))
          </tbody></table>
        </td>
      </tr>
    </tbody></table>
    <p>{0}</p>
  </dd>
</dl>
EOF
  end

  def write_class(fp, node)
    name = self.conv_inline_markup(node.name)
    base = self.conv_inline_markup(node.base)

    if node.including != nil
      mods = node.including.split()
      including = mods[0]
      mods.slice(1).each() do [mod]
        including << "&nbsp;" << self.conv_inline_markup(mod)
      end
      including_html = <<EOF.format(including)
<tr>
  <th align="left">including module(s)</th>
  <th align="center">:</th>
  <td><tt>{0}</tt></td>
</tr>
EOF
    else
      including = ""
    end

    fp.write(<<EOF.format(name, base, including, self.conv_inline_markup(node.desc)))
<dl>
  <dt>class <tt>{0}</tt></dt>
  <dd>
    <table>
      <tbody>
        <tr>
          <th align="left">base class</th>
          <th align="center">:</th>
          <td><tt>{1}</tt></td>
          {2}
        </tr>
      </tbody>
    </table>
    <p>{3}</p>
EOF

    node.attrs.each() do [attr]
      if attr.kind_of?(ClassmethodNode)
        self.write_method(fp, attr, "classmethod")
      elif attr.kind_of?(MethodNode)
        self.write_method(fp, attr, "method")
      elif attr.kind_of?(AttributeNode)
        self.write_attribute(fp, attr, "attribute")
      elif attr.kind_of?(PropertyNode)
        self.write_attribute(fp, attr, "property")
      end
    end

    fp.write(<<EOF)
  </dd>
</dl>
EOF

  end

  def write_text(fp, s)
    fp.write(self.conv_inline_markup(s))
  end

  def write_title(fp, level, title)
    fp.write(<<EOF.format(level + 1, self.conv_inline_markup(title)))
<h{0}>{1}</h{0}>
EOF
  end

  def start_pretty(fp)
    fp.write("<pre>")
  end

  def end_pretty(fp)
    fp.write("</pre>")
  end

  def write_pretty(fp, s)
    fp.write(self.escape_html(s))
  end

  def start_list(fp)
    fp.write("<ul>")
  end

  def end_list(fp)
    fp.write("</ul>")
  end

  def write_list_item(fp, s)
    fp.write("<li>{0}</li>".format(self.conv_inline_markup(s)))
  end

  def write_markup(fp, s)
    lines = s.split("\n")
    i = 0
    pretty? = false
    while i < lines.size
      line = lines[i]
      if m = (line =~ /\A(=+)/)
        self.write_title(fp, m.end() - 1, line.slice(m.end()).trim())
      elif m = (line =~ /\A\s+/)
        margin = m.end()

        self.start_pretty(fp)
        while i < lines.size
          line = lines[i]
          if !(line =~ /\A\s+/)
            break
          end
          self.write_pretty(fp, line.slice(margin) + "\n")
          i += 1
        end
        self.end_pretty(fp)
        next
      elif m = (line =~ /\A\+/)
        margin_stack = [0]

        self.start_list(fp)
        while i < lines.size
          line = lines[i]
          if m = (line =~ /\A(\s*\+)/)
            margin = m.end() - 1
            if margin_stack[-1] < margin
              margin_stack << margin
              self.start_list(fp)
            elif margin < margin_stack[-1]
              while 0 < j
                self.end_list(fp)
                margin_stack.pop()
                if margin_stack[-1] <= margin
                  break
                end
              end
            end
            self.write_list_item(fp, line.slice(m.end()))
          elif !(line =~ /\A[^\s]/)
            self.write_text(fp, line.trim() + "\n")
          else
            break
          end
          i += 1
        end
        while 0 < margin_stack.size
          margin_stack.pop()
          self.end_list(fp)
        end
        next
      else
        self.write_text(fp, line + "\n")
      end
      i += 1
    end
  end

  def start(fp)
    fp.write(<<EOF)
<html>
<body>
EOF
  end

  def end(fp)
    fp.write(<<EOF)
</body>
</html>
EOF
  end

  def write(fp, nodes)
    self.start(fp)
    nodes.each() do [node]
      if node.kind_of?(ClassNode)
        self.write_class(fp, node)
      elif node.kind_of?(String)
        self.write_markup(fp, node)
      elif node.kind_of?(FunctionNode)
        self.write_method(fp, node, "function")
      else
        raise Exception.new("unknown node: {0}".format(node))
      end
    end
    self.end(fp)
  end
end

nodes = File.open(ARGV[1]) do [fp]
  next Parser.new().parse(fp)
end
File.open(ARGV[2], "w") do [fp]
  HtmlGenerator.new().write(fp, nodes)
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2 filetype=yog
