#!/usr/bin/env python3

from functools import partial
from glob import glob
from os import chdir, close, getcwd, stat, unlink, write
from os.path import abspath, join, splitext
from runpy import run_path
from subprocess import PIPE, Popen, call
from sys import argv
import tempfile

class Configure:

    def __init__(self):
        self.headers = []
        self.functions = []
        self.errno = []
        self.sizeof = []
        self.libraries = []
        self.prefix = ""
        self.config_h_path = None
        self.definitions = []

    def define(self, key, value):
        self.definitions.append((key, value))

    def make_config_h(self, path):
        self.config_h_path = path

    def define_prefix(self, prefix):
        self.prefix = prefix

    def check_header(self, names):
        if not isinstance(names, list):
            return self.check_header([names])
        self.headers += names

    def check_func(self, names):
        if not isinstance(names, list):
            return self.check_func([names])
        self.functions += names

    def check_errno(self, names):
        if not isinstance(names, list):
            return self.check_errno([names])
        self.errno += names

    def check_sizeof(self, names):
        if not isinstance(names, list):
            return self.check_sizeof([names])
        self.sizeof += names

    def check_lib(self, names):
        if not isinstance(names, list):
            return self.check_lib([names])
        self.libraries += names

def mkstemp():
    return tempfile.mkstemp(prefix="dame", suffix=".c")

def run_cc(src, flags):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path] + flags
        with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
            try:
                stdout, _ = proc.communicate()
            finally:
                try:
                    unlink(exe)
                except FileNotFoundError:
                    pass
            return proc.returncode, stdout
    finally:
        unlink(path)

def make_config_name(name):
    upper = name.upper()
    for c in [" ", "/", "."]:
        upper = upper.replace(c, "_")
    return upper

def add_definition(prefix, config_h, name):
    fmt = "{prefix}HAVE_{name}"
    config_h.append((fmt.format(prefix=prefix, name=make_config_name(name)), 1))

def add_definition_if_zero(prefix, config_h, name, src, flags=[]):
    if not isinstance(flags, list):
        return add_definition_if_zero(prefix, config_h, name, src, [flags])

    status, _ = run_cc(src, flags)
    if status != 0:
        return
    add_definition(prefix, config_h, name)

def check_header(prefix, config_h, name):
    src = """\
#include <{name}>

int
main(int argc, const char* argv[])
{{
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, name, src)

def check_func(prefix, config_h, func):
    src = """\
int
main(int argc, const char* argv[])
{{
    void {func}();
    {func}();
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, func, src)

def check_errno(prefix, config_h, errno):
    src = """\
#include <errno.h>

int
main(int argc, const char* argv[])
{{
    {errno};
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, errno, src)

def run_src(src):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path]
        try:
            with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
                proc.communicate()
                if proc.returncode != 0:
                    raise Exception("Cannot compile a given code.")
            with Popen(exe, stdout=PIPE) as proc:
                stdout, _ = proc.communicate()
                return stdout
        finally:
            try:
                unlink(exe)
            except FileNotFoundError:
                pass
    finally:
        unlink(path)

def check_sizeof(prefix, config_h, name):
    src = """\
#include <stdio.h>

int
main(int argc, const char* argv[])
{{
    printf("%zu", sizeof({name}));
    return 0;
}}
""".format(**locals())
    stdout = run_src(src)

    fmt = "{prefix}SIZEOF_{name}"
    s = make_config_name(name.replace("*", "P"))
    config_h.append((fmt.format(prefix=prefix, name=s), int(stdout)))

def check_lib(prefix, config_h, lib):
    src = """\
int
main(int argc, const char* argv[])
{
    return 0;
}
"""
    add_definition_if_zero(prefix, config_h, lib, src, "-l" + lib)

def quote_if_str(val):
    return "\"{val}\"".format(**locals()) if isinstance(val, str) else val

def make_config_h(path, config_h):
    guard = make_config_name(path)
    with open(path, "w") as fp:
        write = fp.write
        write("""\
#ifndef {guard}
#define {guard}
""".format(**locals()))
        for key, value in config_h:
            v = quote_if_str(value)
            write("#define {key} {v}\n".format(**locals()))
        write("""\
#endif
""")

def update_globals(settings, g):
    for key in settings.keys():
        value = settings[key]
        if (not callable(value)) or (value.__module__ != "<run_path>"):
            continue
        value.__globals__.update(g)
        value.__globals__.update(settings)

DEFAULT_FILENAME = "Hanagami"

def configure():
    settings = run_path(DEFAULT_FILENAME)

    conf = Configure()
    g = {
            "define": conf.define,
            "make_config_h": conf.make_config_h,
            "define_prefix": conf.define_prefix,
            "check_header": conf.check_header,
            "check_func": conf.check_func,
            "check_errno": conf.check_errno,
            "check_sizeof": conf.check_sizeof,
            "check_lib": conf.check_lib }
    # ???: I expected settings["configure"].__globals__ keeps init_global, but
    # actual is wrong.
    update_globals(settings, g)

    settings["configure"]()

    prefix = conf.prefix
    config_h = []
    for header in conf.headers:
        check_header(prefix, config_h, header)
    for function in conf.functions:
        check_func(prefix, config_h, function)
    for errno in conf.errno:
        check_errno(prefix, config_h, errno)
    for sizeof in conf.sizeof:
        check_sizeof(prefix, config_h, sizeof)
    for library in conf.libraries:
        check_lib(prefix, config_h, library)
    config_h += conf.definitions
    make_config_h(conf.config_h_path, config_h)

def change_ext(filename, ext):
    return splitext(filename)[0] + ext

class Task:

    def __init__(self):
        self.dirpath = None
        self.sources = None
        self.targets = None
        self.commands = None

    def __repr__(self):
        fmt = "<Task dirpath={0} targets={1} sources={2} commands={3}>"
        args = [self.dirpath, self.targets, self.sources, self.commands]
        return fmt.format(*args)

class Build:

    def __init__(self, dirpath):
        self.dirpath = dirpath
        self.subdirs = []
        self.tasks = []

    def command(self, commands, targets, sources):
        if not isinstance(commands, list):
            return self.command([commands], targets, sources)
        if not isinstance(targets, list):
            return self.command(commands, [targets], sources)
        if not isinstance(sources, list):
            return self.command(commands, targets, [sources])
        task = Task()
        task.dirpath = self.dirpath
        task.targets = targets
        task.sources = sources
        task.commands = commands
        self.tasks.append(task)

    def recurse(self, subdirs):
        if not isinstance(subdirs, list):
            return self.recurse([subdirs])
        self.subdirs += subdirs

    def glob(self, pat):
        cwd = getcwd()
        chdir(self.dirpath)
        try:
            return glob(pat)
        finally:
            chdir(cwd)

    def make_compile_command(self, kw):
        command = ["cc", "-o", "{targets}", "-Wall", "-Werror", "-g", "-O2"]
        command += ["-I" + d for d in kw.get("includes", [])]
        command += ["-c", "{sources}"]
        return " ".join(command)

    def program(self, targets, sources, **kw):
        if not isinstance(targets, list):
            return self.program([targets], sources, **kw)
        if not isinstance(sources, list):
            return self.program(targets, [sources], **kw)

        commands = [self.make_compile_command(kw)]

        objects = [change_ext(source, ".o") for source in sources]
        for source, object_ in zip(sources, objects):
            task = Task()
            task.dirpath = self.dirpath
            task.targets = [object_]
            task.sources = [source]
            task.commands = commands
            self.tasks.append(task)

        task = Task()
        task.dirpath = self.dirpath
        task.targets = targets
        task.sources = objects
        task.commands = ["cc -o {targets} {sources}"]
        self.tasks.append(task)

def mtime_of_file(dirpath, name):
    try:
        return stat(join(dirpath, name)).st_mtime
    except FileNotFoundError:
        return None

def mtime_of_files(dirpath, names):
    l = []
    for name in names:
        mtime = mtime_of_file(dirpath, name)
        if mtime is None:
            continue
        l.append(mtime)
    return l

def is_up_to_date(task):
    dirpath = task.dirpath
    targets_mtime = mtime_of_files(dirpath, task.targets)
    if len(targets_mtime) == 0:
        return False
    sources_mtime = mtime_of_files(dirpath, task.sources)
    return max(sources_mtime) < min(targets_mtime)

def find_task_of_target(target, tasks):
    for task in tasks:
        if target in task.targets:
            return task
    return None

def join_filenames(dirpath, names):
    return " ".join([join(dirpath, name) for name in names])

def resolve(top_dir, task, tasks):
    for source in task.sources:
        t = find_task_of_target(source, tasks)
        if t is None:
            continue
        resolve(top_dir, t, tasks)
    if is_up_to_date(task):
        return
    dirpath = task.dirpath
    for template in task.commands:
        d = {
                "targets": join_filenames(dirpath, task.targets),
                "sources": join_filenames(dirpath, task.sources),
                "top_dir": top_dir }
        command = template.format(**d)
        if call(command, shell=True) != 0:
            raise Exception("Command failed: {command}".format(**locals()))

def find_root_targets(tasks):
    l = []
    for task in tasks:
        for target in task.targets:
            target_is_source = False
            for t in tasks:
                if target in t.sources:
                    target_is_source = True
                    break
            if not target_is_source:
                l.append(task)
                break
    return l

def build(top_dir, dirpath):
    settings = run_path(join(dirpath, DEFAULT_FILENAME))
    b = Build(dirpath)
    g = {
            "command": b.command,
            "program": b.program,
            "glob": b.glob,
            "recurse": b.recurse }
    update_globals(settings, g)
    settings["build"]()
    for subdir in b.subdirs:
        build(top_dir, join(dirpath, subdir))
    tasks = b.tasks
    for root in find_root_targets(tasks):
        resolve(top_dir, root, tasks)

def get_request():
    try:
        return argv[1]
    except IndexError:
        return "build"

def main():
    top_dir = abspath(".")
    d = {
            "build": partial(build, top_dir, top_dir),
            "configure": configure }
    d[get_request()]()

main()

# vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4
