#!/usr/bin/env python3

from functools import partial
from glob import glob
from logging import FileHandler, Formatter, StreamHandler, getLogger
from os import chdir, close, getcwd, mkdir, stat, unlink, write
from os.path import abspath, basename, dirname, exists, join, splitext
from re import match
from runpy import run_path
from subprocess import PIPE, Popen, call
from sys import argv, stdout
from time import localtime, strftime
import tempfile

VAR_DIR = ".tissue"
try:
    mkdir(VAR_DIR)
except FileExistsError:
    pass

def add_log_handler(logger, handler, level, fmt):
    handler.setLevel(level)
    handler.setFormatter(fmt)
    logger.addHandler(handler)

def setup_logger():
    logger = getLogger(__name__)
    logger.setLevel("DEBUG")

    fmt = Formatter(fmt="%(levelname)s: %(message)s")

    log_path = join(VAR_DIR, "build.log")
    add_log_handler(logger, FileHandler(log_path, "w"), "DEBUG", fmt)
    add_log_handler(logger, StreamHandler(stdout), "INFO", fmt)

    return logger

logger = setup_logger()
warn = logger.warn
info = logger.info
debug = logger.debug

class Configure:

    def __init__(self):
        self.headers = []
        self.functions = []
        self.errno = []
        self.sizeof = []
        self.libraries = []
        self.prefix = ""
        self.config_h_path = None
        self.definitions = []

    def define(self, key, value):
        self.definitions.append((self.prefix + key, value))

    def make_config_h(self, path):
        self.config_h_path = path

    def define_prefix(self, prefix):
        self.prefix = prefix

    def check_header(self, names):
        if not isinstance(names, list):
            return self.check_header([names])
        self.headers += names

    def check_func(self, names):
        if not isinstance(names, list):
            return self.check_func([names])
        self.functions += names

    def check_errno(self, names):
        if not isinstance(names, list):
            return self.check_errno([names])
        self.errno += names

    def check_sizeof(self, names):
        if not isinstance(names, list):
            return self.check_sizeof([names])
        self.sizeof += names

    def check_lib(self, names):
        if not isinstance(names, list):
            return self.check_lib([names])
        self.libraries += names

def mkstemp():
    return tempfile.mkstemp(prefix="dame", suffix=".c")

def run_cc(src, flags):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path] + flags
        with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
            try:
                stdout, _ = proc.communicate()
            finally:
                try:
                    unlink(exe)
                except FileNotFoundError:
                    pass
            return proc.returncode, stdout
    finally:
        unlink(path)

def make_config_name(name):
    upper = name.upper()
    for c in [" ", "/", "."]:
        upper = upper.replace(c, "_")
    return upper

def add_definition(prefix, config_h, name):
    fmt = "{prefix}HAVE_{name}"
    config_h.append((fmt.format(prefix=prefix, name=make_config_name(name)), 1))

def add_definition_if_zero(prefix, config_h, name, src, flags=[]):
    if not isinstance(flags, list):
        return add_definition_if_zero(prefix, config_h, name, src, [flags])

    status, _ = run_cc(src, flags)
    if status != 0:
        return
    add_definition(prefix, config_h, name)

def check_header(prefix, config_h, name):
    src = """\
#include <{name}>

int
main(int argc, const char* argv[])
{{
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, name, src)

def check_func(prefix, config_h, func):
    src = """\
int
main(int argc, const char* argv[])
{{
    void {func}();
    {func}();
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, func, src)

def check_errno(prefix, config_h, errno):
    src = """\
#include <errno.h>

int
main(int argc, const char* argv[])
{{
    {errno};
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, errno, src)

def run_src(src):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path]
        try:
            with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
                proc.communicate()
                if proc.returncode != 0:
                    raise Exception("Cannot compile a given code.")
            with Popen(exe, stdout=PIPE) as proc:
                stdout, _ = proc.communicate()
                return stdout
        finally:
            try:
                unlink(exe)
            except FileNotFoundError:
                pass
    finally:
        unlink(path)

def check_sizeof(prefix, config_h, name):
    src = """\
#include <stdio.h>

int
main(int argc, const char* argv[])
{{
    printf("%zu", sizeof({name}));
    return 0;
}}
""".format(**locals())
    stdout = run_src(src)

    fmt = "{prefix}SIZEOF_{name}"
    s = make_config_name(name.replace("*", "P"))
    config_h.append((fmt.format(prefix=prefix, name=s), int(stdout)))

def check_lib(prefix, config_h, lib):
    src = """\
int
main(int argc, const char* argv[])
{
    return 0;
}
"""
    add_definition_if_zero(prefix, config_h, lib, src, "-l" + lib)

def quote_if_str(val):
    return "\"{val}\"".format(**locals()) if isinstance(val, str) else val

def make_config_h(path, config_h):
    guard = make_config_name(path)
    with open(path, "w") as fp:
        write = fp.write
        write("""\
#ifndef {guard}
#define {guard}
""".format(**locals()))
        for key, value in config_h:
            v = quote_if_str(value)
            write("#define {key} {v}\n".format(**locals()))
        write("""\
#endif
""")

def update_globals(settings, g):
    for key in settings.keys():
        value = settings[key]
        if (not callable(value)) or (value.__module__ != "<run_path>"):
            continue
        value.__globals__.update(g)
        value.__globals__.update(settings)

DEFAULT_FILENAME = "Hanagami"

def configure(opts):
    settings = run_path(DEFAULT_FILENAME)

    conf = Configure()
    g = {
            "define": conf.define,
            "make_config_h": conf.make_config_h,
            "define_prefix": conf.define_prefix,
            "check_header": conf.check_header,
            "check_func": conf.check_func,
            "check_errno": conf.check_errno,
            "check_sizeof": conf.check_sizeof,
            "check_lib": conf.check_lib }
    # ???: I expected settings["configure"].__globals__ keeps init_global, but
    # actual is wrong.
    update_globals(settings, g)

    settings["configure"](opts)

    prefix = conf.prefix
    config_h = []
    for header in conf.headers:
        check_header(prefix, config_h, header)
    for function in conf.functions:
        check_func(prefix, config_h, function)
    for errno in conf.errno:
        check_errno(prefix, config_h, errno)
    for sizeof in conf.sizeof:
        check_sizeof(prefix, config_h, sizeof)
    for library in conf.libraries:
        check_lib(prefix, config_h, library)
    config_h += conf.definitions
    make_config_h(conf.config_h_path, config_h)

def change_ext(filename, ext):
    return splitext(filename)[0] + ext

class Task:

    def __init__(self):
        self.dirpath = None
        self.sources = None
        self.targets = None
        self.commands = None
        self.includes = None
        self.additional_sources = []

    def __repr__(self):
        fmt = "<Task dirpath={0} targets={1} sources={2} commands={3}>"
        args = [self.dirpath, self.targets, self.sources, self.commands]
        return fmt.format(*args)

class Build:

    def __init__(self, dirpath):
        self.dirpath = dirpath
        self.subdirs = []
        self.tasks = []

    def command(self, commands, targets, sources):
        if not isinstance(commands, list):
            return self.command([commands], targets, sources)
        if not isinstance(targets, list):
            return self.command(commands, [targets], sources)
        if not isinstance(sources, list):
            return self.command(commands, targets, [sources])
        task = Task()
        task.dirpath = self.dirpath
        task.targets = targets
        task.sources = sources
        task.commands = commands
        self.tasks.append(task)

    def recurse(self, subdirs):
        if not isinstance(subdirs, list):
            return self.recurse([subdirs])
        self.subdirs += subdirs

    def glob(self, pat):
        dirpath = self.dirpath
        return [name[len(dirpath) + 1:] for name in glob(join(dirpath, pat))]

    def make_compile_command(self, kw):
        command = ["cc", "-o", "{targets}", "-Wall", "-Werror", "-g", "-O2"]
        command += ["-I" + d for d in kw.get("includes", [])]
        command += ["-c", "{sources}"]
        return " ".join(command)

    def program(self, targets, sources, **kw):
        if not isinstance(targets, list):
            return self.program([targets], sources, **kw)
        if not isinstance(sources, list):
            return self.program(targets, [sources], **kw)

        commands = [self.make_compile_command(kw)]
        includes = kw.get("includes", [])

        objects = [change_ext(source, ".o") for source in sources]
        for source, object_ in zip(sources, objects):
            task = Task()
            task.dirpath = self.dirpath
            task.targets = [object_]
            task.sources = [source]
            task.commands = commands
            task.includes = includes
            self.tasks.append(task)

        task = Task()
        task.dirpath = self.dirpath
        task.targets = targets
        task.sources = objects
        task.commands = ["cc -o {targets} {sources}"]
        self.tasks.append(task)

def mtime_of_file(path):
    try:
        return stat(path).st_mtime
    except FileNotFoundError:
        return None

def mtime_of_files(dirpath, names):
    l = []
    for name in names:
        path = join(dirpath, name)
        mtime = mtime_of_file(path)
        if mtime is None:
            continue
        l.append((path, mtime))
    l.sort(key=lambda t: t[1])
    return l

def log_file_info(msg, t):
    path = t[0]
    tm = strftime("%Y-%m-%d %H:%M:%S", localtime(t[1]))
    debug("{msg}: {path}, {tm}".format(**locals()))

def is_up_to_date(task):
    dirpath = task.dirpath
    targets_mtime = mtime_of_files(dirpath, task.targets)
    if len(targets_mtime) == 0:
        return False
    sources = task.sources + task.additional_sources
    sources_mtime = mtime_of_files(dirpath, sources)
    youngest_source = sources_mtime[-1]
    oldest_target = targets_mtime[0]

    log_file_info("Youngest source", youngest_source)
    log_file_info("Oldest target", oldest_target)

    return youngest_source[1] < oldest_target[1]

def find_task_of_target(target, tasks):
    for task in tasks:
        if target in task.targets:
            return task
    return None

def join_filenames(dirpath, names):
    return " ".join([join(dirpath, name) for name in names])

def resolve(top_dir, task, tasks):
    debug("Resolving: {task}".format(**locals()))
    for source in task.sources + task.additional_sources:
        t = find_task_of_target(source, tasks)
        if t is None:
            continue
        resolve(top_dir, t, tasks)
    if is_up_to_date(task):
        debug("Skip: {task}".format(**locals()))
        return
    debug("Must update: {task}".format(**locals()))
    dirpath = task.dirpath
    for template in task.commands or []:
        d = {
                "targets": join_filenames(dirpath, task.targets),
                "sources": join_filenames(dirpath, task.sources),
                "top_dir": top_dir }
        command = template.format(**d)
        cwd_old = getcwd()
        chdir(task.dirpath)
        try:
            debug("Chdir: {0}".format(task.dirpath))
            debug("Execute: {command}".format(**locals()))
            if call(command, shell=True) != 0:
                raise Exception("Command failed: {command}".format(**locals()))
        finally:
            chdir(cwd_old)

def find_root_targets(tasks):
    l = []
    for task in tasks:
        for target in task.targets:
            target_is_source = False
            for t in tasks:
                if target in t.sources:
                    target_is_source = True
                    break
            if not target_is_source:
                l.append(task)
                break
    return l

def find_in_includes(path, includes, top_dir=""):
    for include in includes:
        fullpath = join(include.format(**locals()), path)
        if exists(fullpath):
            return fullpath
    return None

def add_included_sources(tasks, top_dir):
    for task in tasks:
        for source in task.sources:
            if splitext(source)[1] != ".c":
                continue
            with open(join(task.dirpath, source)) as fp:
                for line in fp:
                    m = match(r"#include [\"<](?P<path>.*)[\">]", line.strip())
                    if m is None:
                        continue
                    path = m.group("path")
                    system_include_dir = ["/usr/include", "/usr/local/include"]
                    if find_in_includes(path, system_include_dir) is not None:
                        # The header file is found in a system include
                        # directory. Updating such file is rare, so it is
                        # ignored.
                        continue
                    includes = [task.dirpath] + task.includes
                    fullpath = find_in_includes(path, includes, top_dir)
                    if fullpath is not None:
                        # The included file is found in a user's include
                        # directory.
                        task.additional_sources.append(fullpath)
                        continue
                    t = find_task_of_target(basename(path), tasks)
                    if t is None:
                        # In here case:
                        # 1. The included file is not found in any directories. 
                        # 2. The included file is not a target of any tasks.
                        # I don't know how to generate it.
                        fmt = "WARNING: Cannot find a task for {path}"
                        print(fmt.format(**locals()))
                        continue
                    task.additional_sources.extend(t.targets)

def log_tasks(tasks):
    for i, task in enumerate(tasks):
        debug("taks[{i}]: {task}".format(**locals()))

def build(top_dir, dirpath, opts):
    settings = run_path(join(dirpath, DEFAULT_FILENAME))
    b = Build(dirpath)
    g = {
            "command": b.command,
            "program": b.program,
            "glob": b.glob,
            "recurse": b.recurse }
    update_globals(settings, g)
    settings["build"]()
    for subdir in b.subdirs:
        build(top_dir, join(dirpath, subdir), opts)
    tasks = b.tasks
    add_included_sources(tasks, top_dir)
    for root in find_root_targets(tasks):
        resolve(top_dir, root, tasks)

def get_request():
    try:
        return argv[1]
    except IndexError:
        return "build"

def parse_options(args):
    opts = {}
    for s in args:
        if s[:2] != "--":
            break
        pos = s.find("=")
        opts[s[2:pos]] = s[pos + 1:]
    return opts

def main():
    top_dir = abspath(".")
    d = {
            "build": partial(build, top_dir, top_dir),
            "configure": configure }
    d[get_request()](parse_options(argv[2:]))
    debug("End")

main()

# vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4
