
from lalr1 import Token
import c.grammar
import lalr1

class Node
  def init(filename)
    self.filename = filename
  end
end

class Macro > Node
  def init(filename, name, args)
    super(filename)
    self.name = name
    self.args = args
  end

  def to_s()
    return "<Macro filename=\"{0}\" name=\"{1}\" args={2}>".format(self.filename, self.name, self.args)
  end
end

class Lexer
  def init(src)
    self.src = src
    self.macros = []
    self.bol? = true # begin of line
    self.pos = 0
    self.filename = ""
  end

  def get_filename()
    m = /# \d+ "(?<filename>.*)"/.match(self.src, self.pos)
    return m == nil ? nil : m.group("filename").to_path()
  end

  def find_next_line()
    if (pos = self.src.find("\n", self.pos)) == nil
      return self.src.size
    end
    return pos + 1
  end

  def skip_to_next_line()
    self.pos = self.find_next_line()
    self.bol? = true
  end

  def get_macro()
    m = /#define (?<name>\w+)(?<args>\([\w\s,]*\))?/.match(self.src, self.pos)
    if m == nil
      return nil
    end
    s = m.group("args")
    args = s != nil ? s.slice(1, -1) : nil
    return Macro.new(self.filename, m.group("name"), args)
  end

  def skip_whitespace()
    m = /\s*/.match(self.src, self.pos)
    if m == nil
      return
    end
    self.pos = m.end()
  end

  def match(regexp)
    m = regexp.match(self.src, self.pos)
    if m == nil
      return nil
    end
    self.pos = m.end()
    return m
  end

  def get_next_token()
    if self.bol?
      if (filename = self.get_filename()) != nil
        self.filename = filename
        self.skip_to_next_line()
        return self.get_next_token()
      end
      if (macro = self.get_macro()) != nil
        self.macros << macro
        self.skip_to_next_line()
        return self.get_next_token()
      end
    end
    self.bol? = false
    self.skip_whitespace()
    if (m = self.match(/\d+/)) != nil
      return Token.new('constant, m.group().to_i())
    end
    syms = { ";": 'semicolon }
    syms.each() do [key, value]
      if self.src.slice(self.pos, key.size) != key
        next
      end
      self.pos += key.size
      return Token.new(value)
    end
    return nil
  end
end

def parse(src)
  lexer = Lexer.new(src)
  nodes = lalr1.parse(c.grammar, lexer.get_next_token)
  return nodes, lexer.macros
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
