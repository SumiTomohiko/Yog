
from peg import action, pattern

class Token
  def init(lineno, value=nil)
    self.lineno = lineno
    self.value = value
  end
end

class Indent > Token
  def to_s()
    return "<Indent line {0}>".format(self.lineno)
  end
end

class Dedent > Token
  def to_s()
    return "<Dedent line {0}>".format(self.lineno)
  end
end

class Klass > Token
  def to_s()
    return "<Klass line {0}>".format(self.lineno)
  end
end

class Base > Token
  def to_s()
    return "<Base line {0}>".format(self.lineno)
  end
end

class Including > Token
  def to_s()
    return "<Including line {0}>".format(self.lineno)
  end
end

class Method > Token
  def to_s()
    return "<Method line {0}>".format(self.lineno)
  end
end

class Parameters > Token
  def to_s()
    return "<Parameters line {0}>".format(self.lineno)
  end
end

class Return > Token
  def to_s()
    return "<Return line {0}>".format(self.lineno)
  end
end

class Data > Token
  def to_s()
    return "<Data line {0}>".format(self.lineno)
  end
end

class Type > Token
end

class Attribute > Token
  def to_s()
    return "<Attribute line {0}>".format(self.lineno)
  end
end

class Property > Token
  def to_s()
    return "<Property line {0}>".format(self.lineno)
  end
end

class Classmethod > Token
  def to_s()
    return "<Classmethod line {0}>".format(self.lineno)
  end
end

class Function > Token
  def to_s()
    return "<Function line {0}>".format(self.lineno)
  end
end

class Colon > Token
  def to_s()
    return "<Colon line {0}>".format(self.lineno)
  end
end

class Newline > Token
  def to_s()
    return "<Newline line {0}>".format(self.lineno)
  end
end

class Text > Token
  def to_s()
    return "<Text line {1}, {0}>".format(self.value.inspect(), self.lineno)
  end
end

class Method > Token
end

class Return > Token
end

class Exceptions > Token
end

class Parameters > Token
end

class Block > Token
end

KEY2TOKEN = {
  "attribute" => Attribute,
  "base" => Base,
  "block" => Block,
  "class" => Klass,
  "classmethod" => Classmethod,
  "data" => Data,
  "exceptions" => Exceptions,
  "function" => Function,
  "including" => Including,
  "method" => Method,
  "parameters" => Parameters,
  "property" => Property,
  "return" => Return,
  "type" => Type }

class Lexer
  def init(fp)
    self.fp = fp
    self.lineno = 0
    self.margin_stack = [0]
    self.text_last? = false
  end

  def get_margin(line)
    return (line =~ /\A\s*/).end(0)
  end

  def generate_dedent_tokens(line)
    margin = self.get_margin(line)
    tokens = []
    while !self.margin_stack.empty?
      if self.margin_stack[-1] <= margin
        return tokens
      end
      self.margin_stack.pop()
      tokens << Dedent.new(self.lineno)
    end
  end

  def generate_indent_tokens(line)
    margin = self.get_margin(line)
    if self.margin_stack[-1] < margin
      if self.text_last?
        return []
      end
      self.margin_stack.push(margin)
      return [Indent.new(self.lineno)]
    end

    return self.generate_dedent_tokens(line)
  end

  def readline()
    comment_depth = 0
    while line = self.fp.readline()
      self.lineno += 1
      if line =~ /\A\s*--/
        comment_depth += 1
        next
      end
      if line =~ /\A\s*\+\+/
        comment_depth -= 1
        next
      end
      if 0 < comment_depth
        next
      end

      if line =~ /\A\s*#/
        next
      end
      if !self.text_last? && (line =~ /\A\s*\z/)
        next
      end
      break
    end
    return line
  end

  def split_key_value(line)
    size = line.size
    i = 0
    while i < size
      if line[i] == ":"
        i += 1
        if line[i] != ":"
          key = line.slice(0, i - 1).trim()
          value = line.slice(i).trim()
          return key, value
        end
      end
      i += 1
    end

    return nil, nil
  end

  def cut_margin(line)
    margin = self.margin_stack[-1]
    if line.size < margin
      return "\n"
    end
    return line.slice(margin)
  end

  def split_tokens(line)
    if self.text_last? && (line =~ /\A\s*\Z/)
      return [Text.new(self.lineno, self.cut_margin(line))]
    end
    tokens = self.generate_indent_tokens(line)

    key, value = self.split_key_value(line)
    if key != nil
      tokens << KEY2TOKEN.get(key, Text).new(self.lineno, key)
      tokens << Colon.new(self.lineno)
      tokens << Text.new(self.lineno, value)
      tokens << Newline.new(self.lineno)
      self.text_last? = false
      return tokens
    end

    tokens << Text.new(self.lineno, self.cut_margin(line.gsub("::", ":")))
    self.text_last? = true
    return tokens
  end

  def get_tokens()
    tokens = []
    while line = self.readline()
      tokens += self.split_tokens(line)
    end
    tokens += self.generate_dedent_tokens("")
    return tokens
  end
end

class Node
end

class TextNode > Node
end

class ClassNode > Node
  def init(name, base, including, desc, attrs)
    self.name = name
    self.base = base
    self.including = including
    self.desc = desc
    self.attrs = attrs
  end

  def to_s()
    return "<ClassNode {0}>".format(self.name)
  end
end

class AttributeNode > Node
  def init(name, type, desc)
    self.name = name
    self.type = type
    self.desc = desc
  end
end

class PropertyNode > AttributeNode
end

class MethodNode > Node
  def init(sig, params, return_, excs, block, desc)
    self.sig = sig
    self.params = params
    self.return_ = return_
    self.excs = excs
    self.block = block
    self.desc = desc
  end

  def to_s()
    return "<MethodNode {0}>".format(self.sig)
  end
end

class FunctionNode > MethodNode
end

class ClassmethodNode > MethodNode
end

class ParameterNode > Node
  def init(name, desc)
    self.name = name
    self.desc = desc
  end
end

class ExceptionNode > Node
  def init(type, desc)
    self.type = type
    self.desc = desc
  end
end

class DataNode > Node
  def init(name, type, desc)
    self.name = name
    self.type = type
    self.desc = desc
  end
end

def token_pattern(klass)
  return pattern(klass) do [pat, act]
    next act.kind_of?(pat)
  end
end

klass_token = token_pattern(Klass)
colon_token = token_pattern(Colon)
text_token = token_pattern(Text)
newline_token = token_pattern(Newline)
indent_token = token_pattern(Indent)
dedent_token = token_pattern(Dedent)
base_token = token_pattern(Base)
including_token = token_pattern(Including)
method_token = token_pattern(Method)
function_token = token_pattern(Function)
classmethod_token = token_pattern(Classmethod)
parameters_token = token_pattern(Parameters)
return_token = token_pattern(Return)
exceptions_token = token_pattern(Exceptions)
property_token = token_pattern(Property)
attribute_token = token_pattern(Attribute)
data_token = token_pattern(Data)
type_token = token_pattern(Type)
block_token = token_pattern(Block)

text = action(text_token ^ 1) do [tokens]
  s = ""
  tokens.each() do [token]
    s << token.value
  end
  next s
end
base = action(base_token * colon_token * text_token * newline_token) do [ignore1, ignore2, text, ignore3]
  next text.value
end
including = action(including_token * colon_token * text_token * newline_token) do [ignore1, ignore2, text, ignore3]
  next text.value
end
exceptions_body = action(indent_token * ((text_token * colon_token * text_token * newline_token * ((indent_token * text * dedent_token) ^ (-1))) ^ 0) * dedent_token) do [ignore1, excs, ignore2]
  a = []
  excs.each() do [exc]
    a << ExceptionNode.new(exc[0].value, exc[2].value + exc[4].get(0, ""))
  end
  next a
end
exceptions = action(exceptions_token * colon_token * text_token * newline_token * exceptions_body) do [ignore1, ignore2, ignore3, ignore4, excs]
  next excs
end
return_ = action(return_token * colon_token * text_token * newline_token * ((indent_token * text * dedent_token) ^ (-1))) do [ignore1, ignore2, desc, ignore, desc2]
  s = desc.value + "\n"
  desc2.each() do [text]
    s << text[1]
  end
  next s
end
parameters_body = action(indent_token * ((text_token * colon_token * text_token * newline_token) ^ 0) * dedent_token) do [ignore1, params, ignore2]
  a = []
  params.each() do [param]
    a << ParameterNode.new(param[0].value, param[2].value)
  end
  next a
end
parameters = action(parameters_token * colon_token * text_token * newline_token * (parameters_body ^ (-1))) do [ignore1, ignore2, ignore3, ignore4, body]
  next body.get(0, [])
end
block = action(block_token * colon_token * text_token * newline_token) do [ignore1, ignore2, sig, ignore3]
  next sig.value
end
method_body = action(indent_token * (parameters ^ (-1)) * (return_ ^ (-1)) * (exceptions ^ (-1)) * (block ^ (-1)) * (text ^ (-1)) * dedent_token) do [ignore1, params, return_, excs, block, desc, ignore2]
  next [params.get(0, []), return_.get(0), excs.get(0, []), block.get(0, ""), desc.get(0)]
end
classmethod = action(classmethod_token * colon_token * text_token * newline_token * (method_body ^ (-1))) do [ignore1, ignore2, sig, ignore3, bodies]
  body = bodies.get(0, [[], "", [], "", ""])
  next ClassmethodNode.new(sig.value, body[0], body[1], body[2], body[3], body[4])
end
function = action(function_token * colon_token * text_token * newline_token * (method_body ^ (-1))) do [ignore1, ignore2, sig, ignore3, bodies]
  body = bodies.get(0, [[], "", [], "", ""])
  next FunctionNode.new(sig.value, body[0], body[1], body[2], body[3], body[4])
end
method = action(method_token * colon_token * text_token * newline_token * (method_body ^ (-1))) do [ignore1, ignore2, sig, ignore3, bodies]
  body = bodies.get(0, [[], "", [], "", ""])
  next MethodNode.new(sig.value, body[0], body[1], body[2], body[3], body[4])
end
attribute = action(attribute_token * colon_token * text_token * newline_token * ((indent_token * type_token * colon_token * text_token * newline_token * (text ^ (-1)) * dedent_token) ^ (-1))) do [ignore1, ignore2, name, ignore3, body_opt]
  body = body_opt.get(0, [])
  if body.get(3) == nil
    type = ""
  else
    type = body[3].value
  end
  if body.get(5) == nil
    desc = ""
  else
    desc = body[5].get(0, "")
  end
  next AttributeNode.new(name.value, type, desc)
end
prop = action(property_token * colon_token * text_token * newline_token * ((indent_token * type_token * colon_token * text_token * newline_token * (text ^ (-1)) * dedent_token) ^ (-1))) do [ignore1, ignore2, name, ignore3, body_opt]
  body = body_opt.get(0, [])
  if body.get(3) == nil
    type = ""
  else
    type = body[3].value
  end
  if body.get(5) == nil
    desc = ""
  else
    desc = body[5].get(0, "")
  end
  next PropertyNode.new(name.value, type, desc)
end
data = action(data_token * colon_token * text_token * newline_token * ((indent_token * type_token * colon_token * text_token * newline_token * (text ^ (-1)) * dedent_token) ^ (-1))) do [ignore1, ignroe2, name, ignore3, bodies]
  body = bodies.get(0, [])
  if body.get(3) != nil
    type = body[3].value
  else
    type = ""
  end
  if body.get(5) != nil
    desc = body[5].get(0, "")
  else
    desc = ""
  end
  next DataNode.new(name.value, type, desc)
end
attr = action(prop / method / classmethod / attribute) do [attr]
  next attr
end
klass_body = action(indent_token * (base ^ (-1)) * (including ^ (-1)) * (text ^ (-1)) * (attr ^ 0) * dedent_token) do [ignore1, base, including, text, attrs, ignore2]
  next [base.get(0), including.get(0), text.get(0, ""), attrs]
end
klass_body_opt = action(klass_body ^ (-1)) do [body]
  next body.get(0, ["", "", "", []])
end
klass = action(klass_token * colon_token * text_token * newline_token * klass_body_opt) do [ignore1, ignore2, name, ignore3, body]
  next ClassNode.new(name.value, body[0], body[1], body[2], body[3])
end
grammar = (text / klass / function / data) ^ 0

class Parser
  def parse(fp)
    tokens = Lexer.new(fp).get_tokens()
    m = grammar.match(tokens)
    if m == nil
      raise SyntaxError.new("invalid tokens")
    end
    if !m.rest.empty?
      next_token = m.rest[0]
      msg = "line {0}: invalid token: {1}".format(next_token.lineno, next_token)
      raise SyntaxError.new(msg)
    end
    return m.matched
  end
end

class List
  def init(margin, type)
    self.margin = margin
    self.type = type      # "*" or "+"
  end
end

class Generator
  def make_typewriter(s)
  end

  def make_link(ydoc, text, url)
  end

  def conv_char(c)
    return c
  end

  def make_newline()
    return "\n"
  end

  def conv_inline_markup(ydoc, s)
    if s == nil
      return ""
    end
    s = s.rtrim()

    i = 0
    t = ""
    link = ""
    while i < s.size
      if s[i] == "+"
        i += 1
        body = ""
        while s[i] != "+"
          body << self.conv_char(s[i])
          i += 1
        end
        t << self.make_typewriter(body)
      elif s[i] == "\n"
        t << self.make_newline()
      elif s[i] == "{"
        i += 1
        link = ""
        while s[i] != "}"
          link << s[i]
          i += 1
        end
        i += 1
      elif s[i] == "["
        i += 1
        url = ""
        while s[i] != "]"
          url << s[i]
          i += 1
        end
        i += 1
        t << self.make_link(ydoc, link, url)
        link = ""
      else
        t << self.conv_char(s[i])
      end
      i += 1
    end

    return t
  end

  def write_attribute(ydoc, attr, type)
  end

  def make_param(param)
  end

  def write_method(ydoc, meth, type)
  end

  def write_class(ydoc, node)
    node.attrs.each() do [attr]
      if attr.kind_of?(ClassmethodNode)
        self.write_method(ydoc, attr, "classmethod")
      elif attr.kind_of?(MethodNode)
        self.write_method(ydoc, attr, "method")
      elif attr.kind_of?(PropertyNode)
        self.write_attribute(ydoc, attr, "property")
      elif attr.kind_of?(AttributeNode)
        self.write_attribute(ydoc, attr, "attribute")
      end
    end
  end

  def write_text(ydoc, s)
  end

  def conv_inline_markup_to_plain_text(ydoc, s)
    t = ""
    i = 0
    while i < s.size
      if s[i] == "+"
      else
        t << s[i]
      end
      i += 1
    end
    return t
  end

  def write_title(ydoc, level, title)
  end

  def start_pretty()
  end

  def end_pretty()
  end

  def write_pretty(s)
  end

  def start_list()
  end

  def end_list()
  end

  def start_ordered_list()
  end

  def end_ordered_list()
  end

  def write_list_item(ydoc, s)
  end

  def write_ordered_list_item(ydoc, s)
  end

  def start_paragraph(ydoc)
  end

  def end_paragraph(ydoc)
  end

  def write_markup(ydoc, s)
    if s == nil
      return
    end

    @bind(self)
    def end_paragraph()
      nonlocal paragraph?
      if !paragraph?
        return
      end
      self.end_paragraph(ydoc)
      paragraph? = false
    end

    paragraph? = false
    lines = s.split("\n")
    i = 0
    while i < lines.size
      line = lines[i]
      if m = (line =~ /\A(=+)/)
        end_paragraph()
        self.write_title(ydoc, m.end() - 1, line.slice(m.end()).trim())
      elif m = (line =~ /\A\s+/)
        end_paragraph()

        margin = m.end()
        self.start_pretty()
        while i < lines.size
          line = lines[i]
          if !(line =~ /\A\s+/)
            break
          end
          self.write_pretty(line.slice(margin) + "\n")
          i += 1
        end
        self.end_pretty()
        next
      elif m = (line =~ /\A(\+|\*)\s+/)
        end_paragraph()

        type = m.group(1)
        list_stack = [List.new(0, type)]
        if type == "*"
          self.start_list()
        else
          self.start_ordered_list()
        end

        while i < lines.size
          line = lines[i]
          if m = (line =~ /\A(\s*)(\+|\*)\s+/)
            margin = m.end(1)
            type = m.group(2)
            if list_stack[-1].margin < margin
              list_stack << List.new(margin, type)
              if type == "*"
                self.start_list()
              else
                self.start_ordered_list()
              end
            elif margin < list_stack[-1].margin
              while !list_stack.empty? && (margin < list_stack[-1].margin)
                list = list_stack.pop()
                if list.type == "*"
                  self.end_list()
                else
                  self.end_ordered_list()
                end
              end
            end
            s = line.slice(m.end())
            if type == "*"
              self.write_list_item(ydoc, s)
            else
              self.write_ordered_list_item(ydoc, s)
            end
          elif !(line =~ /\A[^\s]/)
            self.write_text(ydoc, line.rtrim() + "\n")
          else
            break
          end
          i += 1
        end
        while 0 < list_stack.size
          list = list_stack.pop()
          if list.type == "*"
            self.end_list()
          else
            self.end_ordered_list()
          end
        end
        next
      else
        if !paragraph?
          self.start_paragraph(ydoc)
          paragraph? = true
        end
        self.write_text(ydoc, line + "\n")
      end
      i += 1
    end
  end

  def end(ydoc)
  end

  def write_data(ydoc, node)
  end

  def start(ydoc)
  end

  def generate(ydoc, nodes)
    self.start(ydoc)
    nodes.each() do [node]
      if node.kind_of?(ClassNode)
        self.write_class(ydoc, node)
      elif node.kind_of?(String)
        self.write_markup(ydoc, node)
      elif node.kind_of?(FunctionNode)
        self.write_method(ydoc, node, "function")
      elif node.kind_of?(DataNode)
        self.write_data(ydoc, node)
      else
        raise Exception.new("unknown node: {0}".format(node))
      end
    end
    return self.end(ydoc)
  end
end

class HtmlGenerator > Generator
  def init()
    self.header = ""
    self.body = ""
    self.title = nil
  end

  def escape_html(s)
    t = ""
    s.each_char() do [c]
      tbl = { "<" => "&lt;", ">" => "&gt;", "&" => "&amp;", "\"" => "&quot;" }
      t << tbl.get(c, c)
    end
    return t
  end

  def conv_char(c)
    return self.escape_html(c)
  end

  def make_newline()
    return "<br/>\n"
  end

  def make_typewriter(s)
    return "<tt>" + self.escape_html(s) + "</tt>"
  end

  def make_link(ydoc, text, url)
    if text == ""
      text = ydoc.get_doc_title(url)
    end
    return "<a href=\"{0}\">{1}</a>".format(url.gsub(".ydoc", ".html"), self.conv_inline_markup(ydoc, text))
  end

  def write_attribute(ydoc, attr, type)
    name = self.escape_html(attr.name)
    desc = self.conv_inline_markup(ydoc, attr.desc)
    self.body << <<EOF.format(type, name, desc)
<dl><dt>{0} <tt>{1}</tt></dt><dd><p>{2}</p></dd></dl>
EOF
  end

  def make_param(param)
    if (pos = param.find("=")) < 0
      return "<i>{0}</i>".format(param)
    end
    name = param.slice(0, pos)
    expr = param.slice(pos + 1)
    return "<i>{0}</i><tt>={1}</tt>".format(name, expr)
  end

  def make_method_signature(sig)
    m = sig.match(/\A(.*)\((.*)\)\Z/)
    s = "<tt>{0}(</tt>".format(m.group(1))

    params = m.group(2).split(/\s*,\s*/)
    s += self.make_param(params[0])
    params.slice(1).each() do [param]
      nonlocal s
      s += "<tt>,</tt> " + self.make_param(param)
    end

    s += "<tt>)</tt>"
    return s
  end

  def write_method(ydoc, meth, type)
    self.body << <<EOF.format(type, self.make_method_signature(meth.sig))
<dl>
  <dt>{0} {1}</dt>
  <dd>
    <table><tbody>
      <tr>
        <th align="left">Parameter(s)</th>
        <th>:</th>
        <td>
          <table border="0"><tbody>
EOF
    meth.params.each() do [param]
      name = self.escape_html(param.name)
      desc = self.conv_inline_markup(ydoc, param.desc)
      self.body << <<EOF.format(name, desc)
            <tr><td><i>{0}</i></td><td>--</td><td>{1}</td></tr>
EOF
    end
    self.body << <<EOF.format(self.conv_inline_markup(ydoc, meth.return_))
          </tbody></table>
        </td>
      </tr>
      <tr>
        <th align="left">Return</th>
        <th>:</th>
        <td>{0}</td>
      </tr>
      <tr>
        <th align="left">Exception(s)</th>
        <th>:</th>
        <td>
          <table><tbody>
EOF
    meth.excs.each() do [exc]
      type = self.escape_html(exc.type)
      desc = self.conv_inline_markup(ydoc, exc.desc)
      self.body << <<EOF.format(type, desc)
            <tr><td><tt>{0}</tt></td><td>--</td><td>{1}</td></tr>
EOF
    end
    self.body << <<EOF
          </tbody></table>
        </td>
      </tr>
    </tbody></table>
EOF
    self.write_markup(ydoc, meth.desc)
    self.body << <<EOF
  </dd>
</dl>
EOF
  end

  def write_class(ydoc, node)
    name = self.conv_inline_markup(ydoc, node.name)
    base = self.conv_inline_markup(ydoc, node.base)

    if node.including != nil
      mods = node.including.split()
      including = mods[0]
      mods.slice(1).each() do [mod]
        including << "&nbsp;" << self.conv_inline_markup(ydoc, mod)
      end
      including_html = <<EOF.format(including)
<tr>
  <th align="left">including module(s)</th>
  <th align="center">:</th>
  <td><tt>{0}</tt></td>
</tr>
EOF
    else
      including = ""
    end

    self.body << <<EOF.format(name, base, including, self.conv_inline_markup(ydoc, node.desc))
<dl>
  <dt>class <tt>{0}</tt></dt>
  <dd>
    <table>
      <tbody>
        <tr>
          <th align="left">base class</th>
          <th align="center">:</th>
          <td><tt>{1}</tt></td>
          {2}
        </tr>
      </tbody>
    </table>
    <p>{3}</p>
EOF

    super(ydoc, node)

    self.body << <<EOF
  </dd>
</dl>
EOF

  end

  def write_text(ydoc, s)
    self.body << self.conv_inline_markup(ydoc, s)
  end

  def conv_inline_markup_to_plain_text(ydoc, s)
    t = ""
    i = 0
    while i < s.size
      if s[i] == "+"
      else
        t << s[i]
      end
      i += 1
    end
    return t
  end

  def write_title(ydoc, level, title)
    self.body << <<EOF.format(level + 1, self.conv_inline_markup(ydoc, title))
<h{0}>{1}</h{0}>
EOF

    if self.title != nil
      return
    end
    self.header << <<EOF.format(ydoc.title, self.conv_inline_markup_to_plain_text(ydoc, title))
<title>{0} - {1}</title>
EOF
    self.title = title
  end

  def start_pretty()
    self.body << "<pre>"
  end

  def end_pretty()
    self.body << "</pre>"
  end

  def write_pretty(s)
    self.body << self.escape_html(s)
  end

  def start_list()
    self.body << "<ul>"
  end

  def end_list()
    self.body << "</ul>"
  end

  def start_ordered_list()
    self.body << "<ol>"
  end

  def end_ordered_list()
    self.body << "</ol>"
  end

  def write_list_item(ydoc, s)
    self.body << "<li>{0}</li>".format(self.conv_inline_markup(ydoc, s))
  end

  def end(ydoc)
    return <<EOF.format(self.header, self.body)
<html>
<head>
{0}
</head>
<body>
{1}
</body>
</html>
EOF
  end

  def write_data(ydoc, node)
    self.body << <<EOF.format(node.name, node.type)
<dl>
  <dt>data <tt>{0}</tt></dt>
  <dd>
    <table><tbody><tr>
      <th align="left">Type</th><th align="left">:</th><td><tt>{1}</tt></td>
    </tr></tbody></table>
EOF
    self.write_markup(ydoc, node.desc)
    self.body << <<EOF
  </dd>
</dl>
EOF
  end

  def write_ordered_list_item(ydoc, s)
    self.body << "<li>" << self.conv_inline_markup(ydoc, s) << "</li>"
  end

  def start_paragraph(ydoc)
    self.body << "<p>"
  end

  def end_paragraph(ydoc)
    self.body << "</p>"
  end

  def start(ydoc)
    self.header << <<EOF.format(ydoc.get_path_to_srcdir())
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link rel="stylesheet" href="{0}/default.css" type="text/css"/>
EOF
    self.body << <<EOF.format(self.escape_html(ydoc.title))
<div class="header">{0}</div>
EOF
  end
end

class Ydoc
  def init(title, destdir, src, ext)
    self.title = title
    self.destdir = destdir
    self.path2title = {}
    self.srcs = [src]
    self.srcdir = dirname(src)
    self.ext = ext
    self.current_src = nil
  end

  def get_path_to_srcdir()
    dir = dirname(self.current_src)
    path = "."
    while (dir != ".") && (dir != self.srcdir)
      dir = dirname(dir)
      path += "/.."
    end
    return path
  end

  def replace_ext(path)
    return path.gsub(".ydoc", self.ext)
  end

  def get_doc_title(path)
    # TODO: This is a side effect. Do it explicitly.
    path_from_topdir = join_path(dirname(self.current_src), path)
    self.srcs.push(path_from_topdir)

    try
      return self.path2title[path]
    except KeyError
    end
    File.open(path_from_topdir) do [fp]
      while line = fp.readline()
        if m = (line =~ /\A=+\s+(.*)\Z/)
          title = m.group(1).rtrim()
          if title != ""
            self.path2title[path] = title
            return title
          end
        end
      end
    end
    title = self.replace_ext(path)
    self.path2title[path] = title
    return title
  end

  def run(generator)
    while !self.srcs.empty?
      src = self.srcs.shift()
      self.current_src = src

      nodes = File.open(src) do [fp]
        next Parser.new().parse(fp)
      end
      dest = self.replace_ext(src)
      if dest.starts_with?("/")
        dest = dest.slice(self.srcdir.size + 1)
      end
      path = join_path(self.destdir, dest)
      make_dirs(dirname(path))
      File.open(path, "w") do [fp]
        fp.write(generator.new().generate(self, nodes))
      end
    end
  end
end

class YdocHtml > Ydoc
  def run()
    super(HtmlGenerator)

    css = "default.css"
    copy_file(join_path(self.srcdir, css), join_path(self.destdir, css))
  end
end

def run(title, destdir, src, ext=".html", generator=HtmlGenerator)
  Ydoc.new(title, destdir, src, ext).run(generator)
end

def run_to_html(title, destdir, src)
  YdocHtml.new(title, destdir, src, ".html").run()
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2 filetype=yog
