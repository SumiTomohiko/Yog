
class Token
  def init(type, value=nil)
    self.type = type
    self.value = value
  end

  def to_s()
    return "<Token type={0} value={1}>".format(self.type, self.value)
  end
end

def nop(s)
end

def get_token_internal(get_token, logger)
  token = get_token()
  logger("Read token: {0}".format(token))
  return token
end

def log_state_stack(stack, logger)
  logger("State stack: {0}".format(stack.join(" ")))
end

def parse(gram, get_token, __data__, logger=nil)
  log = logger != nil ? logger : nop

  state_stack = [0]
  stack = []
  token = get_token_internal(get_token, log)
  loop() do
    state = state_stack[-1]
    type = token != nil ? token.type : "$".to_sym()
    act, subinfo = gram.get_action(state, type)
    if act == 'error
      log("Error")
      return nil
    end
    if act == 'shift
      state_stack << subinfo
      log("Shifted to state {0}".format(subinfo))
      log_state_stack(state_stack, log)
      stack << token
      token = get_token_internal(get_token, log)
      next
    end
    if subinfo == 0
      log("Accepted")
      return stack[-1]
    end
    log("Reduced using rule {0}".format(subinfo))
    log(gram.get_rule(subinfo))
    size = gram.get_rule_size(subinfo)
    obj = gram.invoke(subinfo, size == 0 ? [] : stack.slice(- size), __data__)
    stack = stack.slice(0, stack.size - size) + [obj]
    state_stack = state_stack.slice(0, state_stack.size - size)
    next_state = gram.get_next_state(state_stack[-1], subinfo)
    state_stack << next_state
    log("New state is {0}".format(next_state))
    log_state_stack(state_stack, log)
  end
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
