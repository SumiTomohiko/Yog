
from c import Macro, parse, parse_macro
from c.grammar import BinopNode, ConstantNode, EnumNode, PointerNode, ProtoNode, StructNode, TypedefNode, VarNode, get_typedef_name

def build_command(headers, opts)
  cmd = ["/usr/bin/gcc", "-E"] + opts
  headers.each() do [header]
    cmd.extend(["-include", header])
  end
  cmd << "-"
  return cmd
end

class H2YogError > Exception
end

def run_gcc(headers, opts, &block=nil)
  cmd = build_command(headers, opts)
  status, stdout, _ = run_command(*cmd, &block)
  #puts("{0}:{1} status={2}".format(__FILE__, __LINE__, status))
  #puts(stdout)
  #puts(_)
  if status != 0
    raise H2YogError.new("failed: {0}".format(cmd.join(" ")))
  end
  return stdout
end

def parse_to_nodes(headers, verbose, &block)
  nodes, macros = parse(run_gcc(headers, ["-dD"]), verbose)
  return nodes.select(&block), macros.select(&block)
end

def get_macros_implementation(headers, macros)
  if macros.empty?
    return []
  end
  stdout = run_gcc(headers, []) do [stdin]
    macros.each() do [macro]
      stdin.write("{0}\n".format(macro.name))
    end
  end
  mark = "# 1 \"<stdin>\"\n"
  pos = stdout.find(mark, stdout.find("\n"))
  impls = stdout.slice(pos + mark.size).split("\n")
  return impls.slice(0, impls.size - 1) # remove last empty string
end

def spec2yog(spec)
  if spec.kind_of?(StructNode)
    return spec.name.to_s()
  end

  unsigned? = false
  short? = false
  long? = false
  long_long? = false
  basic = 'int
  spec.each() do [sym]
    if sym == 'void
      return 'void.inspect()
    end
    if sym == 'unsigned
      unsigned? = true
    elif sym == 'short
      short? = true
    elif sym == 'long
      if long?
        long_long? = true
      else
        long? = true
      end
    elif sym == 'char
      basic = 'char
    elif sym == 'float
      return 'float.inspect()
    elif sym == 'double
      basic = 'double
    elif !['int, 'signed].include?(sym)
      return sym.to_s()
    end
  end
  if basic == 'char
    return (unsigned? ? 'uchar : 'char).inspect()
  end
  if basic == 'double
    return (long? ? 'longdouble : 'double).inspect()
  end
  if short?
    return (unsigned? ? 'ushort : 'short).inspect()
  end
  if long_long?
    return (unsigned? ? 'ulonglong : 'longlong).inspect()
  end
  if long?
    return (unsigned? ? 'ulong : 'long).inspect()
  end
  return (unsigned? ? 'uint : 'int).inspect()
end

# FIXME: DON'T DO IT
defined_structs = Set.new()

def make_type_text(spec, decl)
  if decl.kind_of?(ProtoNode) && decl.name.kind_of?(PointerNode)
    return 'pointer.inspect()
  end

  basic = spec2yog(spec)
  if decl.kind_of?(PointerNode)
    name = defined_structs.include?(basic) ? basic : 'void.inspect()
    return "['pointer, {0}]".format(name)
  end
  return basic
end

def enum2yog(node, name)
  yog = name ? "{0} = 'int\n".format(name) : ""

  FMT = "{0} = {1}"
  content = node.contents[0]
  yog << FMT.format(content.name, node2yog(content.expr) || 0) << "\n"
  prev = content.name

  yog << node.contents.slice(1).map() do [content]
    value = node2yog(content.expr) || "{0} + 1".format(prev)
    s = FMT.format(content.name, value)
    prev = content.name
    next s
  end.join("\n")

  return yog
end

def struct2yog(node, name)
  defined_structs << name

  head = <<EOF.format(name, name.to_s().inspect())
{0} = StructClass.new({1})
{0}.define_fields([
EOF
  return head + node.contents.map() do [content]
    next content.names.map() do [name]
      type = make_type_text(content.type, name)
      next <<EOF.rtrim().format(type, get_typedef_name(name).inspect())
  [{0}, {1}]
EOF
    end.join(",\n")
  end.join(",\n").rtrim() + "])\n"
end

def typedef2yog(type, decl)
  name = get_typedef_name(decl)
  return "{0} = {1}\n".format(name, make_type_text(type, decl))
end

def params2yog(params)
  if params.size == 1
    param = params[0]
    spec = param.spec
    if spec.kind_of?(Array) && (spec.size == 1) && (spec[0] == 'void)
      if param.declarators.empty?
        return ""
      end
    end
  end
  return params.map() do [param]
    next make_type_text(param.spec, param.declarators.get(0))
  end.join(", ")
end

def proto2yog(type, decl)
  fmt = "{0} = lib.load_func({1}, [{2}], {3})"
  body = get_pointer_body(decl)
  name = body.name
  params = params2yog(body.params)
  rettype = make_type_text(type, decl)
  return fmt.format(name, name.to_s().inspect(), params, rettype)
end

def node2yog(node)
  if node == nil
    return nil
  end
  if node.kind_of?(BinopNode)
    left = node2yog(node.left)
    right = node2yog(node.right)
    return "({0} {1} {2})".format(left, node.op.to_s(), right)
  end
  if node.kind_of?(ConstantNode)
    return node.value.to_s()
  end
  if node.kind_of?(VarNode)
    return node.name.to_s()
  end
  spec = node.spec
  if spec.kind_of?(TypedefNode)
    type = spec.type
    if type.kind_of?(StructNode) && (type.contents != nil)
      f = struct2yog
    elif type.kind_of?(EnumNode)
      f = enum2yog
    else
      f = typedef2yog
    end
    return node.declarators.map() do [decl]
      next f(type, decl)
    end.join("")
  end
  if spec.kind_of?(StructNode)
    if spec.contents != nil
      return struct2yog(spec, spec.name)
    elif node.declarators.empty?
      return "{0} = {1}\n".format(spec.name, 'void.inspect())
    end
  end
  if spec.kind_of?(EnumNode)
    return enum2yog(spec, spec.name)
  end
  return node.declarators.map() do [decl]
    if decl.kind_of?(ProtoNode)
      next proto2yog(spec, decl)
    end
    if decl.kind_of?(PointerNode) && decl.node.kind_of?(ProtoNode)
      next proto2yog(spec, decl)
    end
    next ""
  end.join("")
end

def get_pointer_body(node)
  return node.kind_of?(PointerNode) ? node.node : node
end

def h2yog(yog, headers, so, verbose=false, &block)
  nodes, macros = parse_to_nodes(headers, verbose) do [node]
    if node == nil
      next false
    end
    if node.kind_of?(Macro)
      next (node.args == nil) && block(node.filename, node.name)
    end
    spec = node.spec
    if spec.kind_of?(StructNode) || spec.kind_of?(EnumNode)
      next block(spec.filename, spec.name)
    end
    next node.declarators.select() do [decl]
      if spec.kind_of?(TypedefNode)
        next block(spec.filename, get_pointer_body(decl))
      end
      if (proto = get_pointer_body(decl)).kind_of?(ProtoNode)
        if proto.name.kind_of?(PointerNode)
          next false
        end
        next block(decl.filename, proto.name)
      end
      next false
    end.size != 0
  end
  #print(macros)
  impls =  get_macros_implementation(headers, macros)
  File.open(yog, "w") do [fp]
    macros.zip(impls).each() do [args]
      macro = args[0]
      impl = args[1]
      node, _ = parse_macro(impl + ";", verbose)
      if (node == nil) || node.empty? || ((src = node2yog(node[0])) == nil)
        next
      end
      fp.write("{0} = {1}\n".format(macro.name, src))
    end
    fp.write("lib = load_lib({0})\n".format(so.inspect()))
    nodes.each() do [node]
      fp.write("{0}\n".format(node2yog(node)))
    end
  end
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
