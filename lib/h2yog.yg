
from c import parse, parse_macro
from c.grammar import ConstantNode, StructNode

def build_command(headers, opts)
  cmd = ["/usr/bin/gcc", "-E"] + opts
  headers.each() do [header]
    cmd.extend(["-include", header])
  end
  cmd << "-"
  return cmd
end

class H2YogError > Exception
end

def run_gcc(headers, opts, &block=nil)
  cmd = build_command(headers, opts)
  status, stdout, _ = run_command(*cmd, &block)
  #puts("{0}:{1} status={2}".format(__FILE__, __LINE__, status))
  #puts(stdout)
  #puts(_)
  if status != 0
    raise H2YogError.new("failed: {0}".format(cmd.join(" ")))
  end
  return stdout
end

def parse_to_nodes(headers, verbose, &block)
  nodes, macros = parse(run_gcc(headers, ["-dD"]), verbose)
  return nodes.select(&block), macros.select(&block)
end

def get_macros_implementation(headers, macros)
  if macros.empty?
    return []
  end
  stdout = run_gcc(headers, []) do [stdin]
    macros.each() do [macro]
      #puts("{0}:{1} macro={2}".format(__FILE__, __LINE__, macro))
      args = macro.args != nil ? "({0})".format(macro.args) : ""
      src = "{0}{1}\n".format(macro.name, args)
      #print("{0}:{1} src={2}".format(__FILE__, __LINE__, src))
      stdin.write(src)
    end
  end
  mark = "# 1 \"<stdin>\"\n"
  pos = stdout.find(mark, stdout.find("\n"))
  impls = stdout.slice(pos + mark.size).split("\n")
  return impls.slice(0, impls.size - 1) # remove last empty string
end

def make_type_text(type)
  unsigned? = false
  short? = false
  long? = false
  long_long? = false
  basic = 'int
  type.each() do [sym]
    if sym == 'unsigned
      unsigned? = true
    elif sym == 'short
      short? = true
    elif sym == 'long
      if long?
        long_long? = true
      else
        long? = true
      end
    elif sym == 'char
      basic = 'char
    elif sym == 'float
      return 'float.inspect()
    elif sym == 'double
      basic = 'double
    end
  end
  if basic == 'char
    return (unsigned? ? 'uchar : 'char).inspect()
  end
  if basic == 'double
    return (long? ? 'longdouble : 'double).inspect()
  end
  if short?
    return (unsigned? ? 'ushort : 'short).inspect()
  end
  if long_long?
    return (unsigned? ? 'ulonglong : 'longlong).inspect()
  end
  if long?
    return (unsigned? ? 'ulong : 'long).inspect()
  end
  return (unsigned? ? 'uint : 'int).inspect()
end

def node2yog(node)
  if node.kind_of?(ConstantNode)
    return node.value.to_s()
  end
  if node.kind_of?(StructNode)
    name = node.name
    head = <<EOF.format(name, name.to_s().inspect())
{0} = StructClass.new({1})
{0}.define_fields([
EOF
    return head + node.contents.map() do [content]
      type = make_type_text(content.type)
      next content.names.map() do [name]
        next <<EOF.rtrim().format(type, name.inspect())
  [{0}, {1}]
EOF
      end.join(",\n")
    end.join(",\n").rtrim() + "])\n"
  end
end

def h2yog(yog, headers, so, verbose=false, &block)
  nodes, macros = parse_to_nodes(headers, verbose) do [node]
    next (node != nil) && block(node.filename, node.name)
  end
  #print(macros)
  impls =  get_macros_implementation(headers, macros)
  File.open(yog, "w") do [fp]
    macros.zip(impls).each() do [args]
      macro = args[0]
      impl = args[1]
      node, _ = parse_macro(impl + ";", verbose)
      if (node == nil) || node.empty? || ((src = node2yog(node[0])) == nil)
        next
      end
      fp.write("{0} = {1}\n".format(macro.name, src))
    end
    nodes.each() do [node]
      fp.write("{0}\n".format(node2yog(node)))
    end
  end
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
