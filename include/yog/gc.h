#if !defined(YOG_GC_H_INCLUDED)
#define YOG_GC_H_INCLUDED

#include "yog/yog.h"

#define ALLOC_OBJ_SIZE(env, keep_children, finalizer, size) \
    YogGC_alloc(env, keep_children, finalizer, size)
#define ALLOC_OBJ(env, keep_children, finalizer, type) \
    ALLOC_OBJ_SIZE(env, keep_children, finalizer, sizeof(type))
#define ALLOC_OBJ_ITEM(env, keep_children, finalizer, type, size, item_type) \
    ALLOC_OBJ_SIZE(env, keep_children, finalizer, sizeof(type) + size * sizeof(item_type))

#if defined(GC_GENERATIONAL)
    /**
     * TODO: PAYLOAD2GENERATION and PAYLOAD2REMEMBERED depend on structs in
     * include/yog/gc/internal.h. These are not good.
     */
#   define PAYLOAD2GENERATION(payload) \
                                (*((uint_t*)(payload) - 1))
#   define GENERATION_YOUNG     0
#   define GENERATION_OLD       1
#   define YogGC_IS_YOUNG(obj)  (PAYLOAD2GENERATION((obj)) == GENERATION_YOUNG)
#   define YogGC_IS_OLD(obj)    (PAYLOAD2GENERATION((obj)) == GENERATION_OLD)
#   define PAYLOAD2REMEMBERED(payload) \
                                (*((uint_t*)(payload) - 2))
#   define YogGC_IS_REMEMBERED(obj) \
                                PAYLOAD2REMEMBERED((obj))
#   define YogGC_UPDATE_PTR(env, obj, member, val) do { \
    do { \
        if (!IS_PTR(PTR2VAL((obj))) || YogGC_IS_YOUNG((obj))) { \
            break; \
        } \
        if (YogGC_IS_REMEMBERED((obj))) { \
            break; \
        } \
        if (!IS_PTR(PTR2VAL((val))) || YogGC_IS_OLD((val))) { \
            break; \
        } \
        YogGC_add_to_remembered_set((env), (obj)); \
    } while (0); \
    (obj)->member = (val); \
} while (0)
#else
#   define YogGC_UPDATE_PTR(env, obj, member, val) do { \
    (obj)->member = (val); \
} while (0)
#endif

#define YogGC_KEEP(env, obj, member, keeper, heap) do { \
    YogVal val = YogGC_keep((env), (obj)->member, (keeper), (heap)); \
    YogGC_UPDATE_PTR((env), (obj), member, val); \
} while (0)

struct YogHeap {
    /**
     * FIXME: YogGenerational's children have also these members, but they are
     * not used.
     */
    struct YogHeap* prev;
    struct YogHeap* next;
    BOOL refered;

    struct {
        uint_t size;
        YogVal* prev;
        YogVal* cur;
        uint_t cur_pos;
    } marked_objects;
};

typedef struct YogHeap YogHeap;

#include <sys/types.h>

/* PROTOTYPE_START */

/**
 * DON'T EDIT THIS AREA. HERE IS GENERATED BY update_prototype.py.
 */
/* src/gc.c */
void YogGC_add_to_remembered_set(YogEnv*, void*);
YogVal YogGC_alloc(YogEnv*, ChildrenKeeper, Finalizer, size_t);
void YogGC_bind_to_gc(YogEnv*);
void YogGC_check_multiply_overflow(YogEnv*, uint_t, uint_t);
void YogGC_compact(YogEnv*);
void YogGC_delete(YogEnv*);
void YogGC_free(YogEnv*, void*, size_t);
void YogGC_free_from_gc(YogEnv*);
void YogGC_init_memory(YogEnv*, void*, size_t);
YogVal YogGC_keep(YogEnv*, YogVal, ObjectKeeper, void*);
void* YogGC_malloc(YogEnv*, size_t);
void YogGC_perform(YogEnv*);
void YogGC_perform_major(YogEnv*);
void YogGC_perform_minor(YogEnv*);
void YogGC_suspend(YogEnv*);
void YogHeap_add_to_marked_objects(YogEnv*, YogHeap*, YogVal);
void YogHeap_finalize(YogEnv*, YogHeap*);
void YogHeap_finish_marked_objects(YogEnv*, YogHeap*);
void YogHeap_init(YogEnv*, YogHeap*);
void YogHeap_init_marked_objects(YogEnv*, YogHeap*);
BOOL YogHeap_is_marked_objects_empty(YogEnv*, YogHeap*);

/* PROTOTYPE_END */

#endif
/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4
 */
