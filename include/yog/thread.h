#if !defined(YOG_THREAD_H_INCLUDED)
#define YOG_THREAD_H_INCLUDED

#include <pthread.h>
#include <setjmp.h>
#include "yog/gc.h"
#include "yog/object.h"
#include "yog/yog.h"

enum YogJmpStatus {
    JMP_RAISE = 1,
    JMP_RETURN = 2,
    JMP_BREAK = 3,
};

typedef enum YogJmpStatus YogJmpStatus;

struct YogJmpBuf {
    struct YogJmpBuf* prev;

    jmp_buf buf;
    YogHandleScope* scope;
    YogLocals* locals;
};

typedef struct YogJmpBuf YogJmpBuf;

struct YogThread {
    struct YogBasicObj base;

    YogVal prev;
    YogVal next;

    uint_t thread_id;
    uint_t next_obj_id;

    YogHeap* heap;
    BOOL gc_bound;

    struct YogJmpBuf* jmp_buf_list;
    YogVal jmp_val;
    YogVal frame_to_long_jump;

    YogVal block;

    pthread_t pthread;

    YogVal recursive_stack;

    YogEnv* env;

    uint_t finish_frames_num;
#define FINISH_FRAMES_MAX 8
    YogVal finish_frames[FINISH_FRAMES_MAX];
    uint_t script_frames_num;
#define SCRIPT_FRAMES_MAX 32
    YogVal script_frames[SCRIPT_FRAMES_MAX];
    uint_t c_frames_num;
#define C_FRAMES_MAX 32
    YogVal c_frames[C_FRAMES_MAX];
};

typedef struct YogThread YogThread;

DECL_AS_TYPE(YogThread_new);
#define TYPE_THREAD TO_TYPE(YogThread_new)

#define INIT_JMPBUF(env, jmpbuf) do { \
    (jmpbuf).scope = (env)->handles->scope; \
    (jmpbuf).locals = (env)->locals->body; \
} while (0)
#define PUSH_JMPBUF(thread, jmpbuf)     do { \
    jmpbuf.prev = PTR_AS(YogThread, (thread))->jmp_buf_list; \
    PTR_AS(YogThread, (thread))->jmp_buf_list = &jmpbuf; \
} while (0)
#define POP_JMPBUF(env)     do { \
    YogJmpBuf* prev = PTR_AS(YogThread, (env)->thread)->jmp_buf_list->prev; \
    PTR_AS(YogThread, (env)->thread)->jmp_buf_list = prev; \
} while (0)

/* PROTOTYPE_START */

/**
 * DON'T EDIT THIS AREA. HERE IS GENERATED BY update_prototype.py.
 */
/* src/thread.c */
YOG_EXPORT void YogThread_config_copying(YogEnv*, YogVal, size_t);
YOG_EXPORT void YogThread_config_generational(YogEnv*, YogVal, size_t, size_t, uint_t);
YOG_EXPORT void YogThread_config_mark_sweep(YogEnv*, YogVal, size_t);
YOG_EXPORT void YogThread_config_mark_sweep_compact(YogEnv*, YogVal, size_t);
YOG_EXPORT void YogThread_define_classes(YogEnv*, YogVal);
YOG_EXPORT YogVal YogThread_get_c_frame(YogEnv*, YogVal);
YOG_EXPORT YogVal YogThread_get_finish_frame(YogEnv*, YogVal);
YOG_EXPORT YogVal YogThread_get_script_frame(YogEnv*, YogVal);
YOG_EXPORT void YogThread_init(YogEnv*, YogVal, YogVal);
YOG_EXPORT void YogThread_issue_object_id(YogEnv*, YogVal, YogVal);
YOG_EXPORT YogVal YogThread_new(YogEnv*);
YOG_EXPORT void YogThread_put_c_frame(YogEnv*, YogVal, YogVal);
YOG_EXPORT void YogThread_put_finish_frame(YogEnv*, YogVal, YogVal);
YOG_EXPORT void YogThread_put_script_frame(YogEnv*, YogVal, YogVal);

/* PROTOTYPE_END */

#include "yog/handle.h"

#endif
/**
 * vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4
 */
