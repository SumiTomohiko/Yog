#!/usr/bin/env python3

from functools import partial
from glob import glob
from os import chdir, close, getcwd, stat, unlink, write
from os.path import abspath, join, splitext
from runpy import run_path
from subprocess import PIPE, Popen, call
from sys import argv
import tempfile

class Configure:

    def __init__(self):
        self.headers = []
        self.functions = []
        self.errno = []
        self.sizeof = []
        self.libraries = []
        self.prefix = ""
        self.config_h_path = None
        self.definitions = []

    def define(self, key, value):
        self.definitions.append((key, value))

    def make_config_h(self, path):
        self.config_h_path = path

    def define_prefix(self, prefix):
        self.prefix = prefix

    def check_header(self, names):
        if not isinstance(names, list):
            return self.check_header([names])
        self.headers += names

    def check_func(self, names):
        if not isinstance(names, list):
            return self.check_func([names])
        self.functions += names

    def check_errno(self, names):
        if not isinstance(names, list):
            return self.check_errno([names])
        self.errno += names

    def check_sizeof(self, names):
        if not isinstance(names, list):
            return self.check_sizeof([names])
        self.sizeof += names

    def check_lib(self, names):
        if not isinstance(names, list):
            return self.check_lib([names])
        self.libraries += names

def mkstemp():
    return tempfile.mkstemp(prefix="dame", suffix=".c")

def run_cc(src, flags):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path] + flags
        with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
            try:
                stdout, _ = proc.communicate()
            finally:
                try:
                    unlink(exe)
                except FileNotFoundError:
                    pass
            return proc.returncode, stdout
    finally:
        unlink(path)

def make_config_name(name):
    upper = name.upper()
    for c in [" ", "/", "."]:
        upper = upper.replace(c, "_")
    return upper

def add_definition(prefix, config_h, name):
    fmt = "{prefix}HAVE_{name}"
    config_h.append((fmt.format(prefix=prefix, name=make_config_name(name)), 1))

def add_definition_if_zero(prefix, config_h, name, src, flags=[]):
    if not isinstance(flags, list):
        return add_definition_if_zero(prefix, config_h, name, src, [flags])

    status, _ = run_cc(src, flags)
    if status != 0:
        return
    add_definition(prefix, config_h, name)

def check_header(prefix, config_h, name):
    src = """\
#include <{name}>

int
main(int argc, const char* argv[])
{{
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, name, src)

def check_func(prefix, config_h, func):
    src = """\
int
main(int argc, const char* argv[])
{{
    void {func}();
    {func}();
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, func, src)

def check_errno(prefix, config_h, errno):
    src = """\
#include <errno.h>

int
main(int argc, const char* argv[])
{{
    {errno};
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, errno, src)

def run_src(src):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path]
        try:
            with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
                proc.communicate()
                if proc.returncode != 0:
                    raise Exception("Cannot compile a given code.")
            with Popen(exe, stdout=PIPE) as proc:
                stdout, _ = proc.communicate()
                return stdout
        finally:
            try:
                unlink(exe)
            except FileNotFoundError:
                pass
    finally:
        unlink(path)

def check_sizeof(prefix, config_h, name):
    src = """\
#include <stdio.h>

int
main(int argc, const char* argv[])
{{
    printf("%zu", sizeof({name}));
    return 0;
}}
""".format(**locals())
    stdout = run_src(src)

    fmt = "{prefix}SIZEOF_{name}"
    s = make_config_name(name.replace("*", "P"))
    config_h.append((fmt.format(prefix=prefix, name=s), int(stdout)))

def check_lib(prefix, config_h, lib):
    src = """\
int
main(int argc, const char* argv[])
{
    return 0;
}
"""
    add_definition_if_zero(prefix, config_h, lib, src, "-l" + lib)

def quote_if_str(val):
    return "\"{val}\"".format(**locals()) if isinstance(val, str) else val

def make_config_h(path, config_h):
    guard = make_config_name(path)
    with open(path, "w") as fp:
        write = fp.write
        write("""\
#ifndef {guard}
#define {guard}
""".format(**locals()))
        for key, value in config_h:
            v = quote_if_str(value)
            write("#define {key} {v}\n".format(**locals()))
        write("""\
#endif
""")

def update_globals(settings, g):
    for key in settings.keys():
        value = settings[key]
        if (not callable(value)) or (value.__module__ != "<run_path>"):
            continue
        value.__globals__.update(g)
        value.__globals__.update(settings)

DAMEFILE = "Damefile"

def configure():
    settings = run_path(DAMEFILE)

    conf = Configure()
    g = {
            "define": conf.define,
            "make_config_h": conf.make_config_h,
            "define_prefix": conf.define_prefix,
            "check_header": conf.check_header,
            "check_func": conf.check_func,
            "check_errno": conf.check_errno,
            "check_sizeof": conf.check_sizeof,
            "check_lib": conf.check_lib }
    # ???: I expected settings["configure"].__globals__ keeps init_global, but
    # actual is wrong.
    update_globals(settings, g)

    settings["configure"]()

    prefix = conf.prefix
    config_h = []
    for header in conf.headers:
        check_header(prefix, config_h, header)
    for function in conf.functions:
        check_func(prefix, config_h, function)
    for errno in conf.errno:
        check_errno(prefix, config_h, errno)
    for sizeof in conf.sizeof:
        check_sizeof(prefix, config_h, sizeof)
    for library in conf.libraries:
        check_lib(prefix, config_h, library)
    config_h += conf.definitions
    make_config_h(conf.config_h_path, config_h)

class Node:

    def __init__(self, name, sources, commands):
        if not isinstance(commands, list):
            return self.__init__(name, sources, [commands])
        if not isinstance(sources, list):
            return self.__init__(name, [sources], commands)
        self.name = name
        self.sources = sources
        self.commands = commands

def change_ext(filename, ext):
    return splitext(filename)[0] + ext

class Command:

    def __init__(self, dirpath, commands, targets, sources):
        self.dirpath = dirpath
        self.commands = commands
        self.targets = targets
        self.sources = sources

    def construct_dependencies(self):
        return []

class Program:

    def __init__(self, dirpath, targets, sources, **kw):
        self.dirpath = dirpath
        self.targets = targets
        self.sources = sources
        self.kw = kw

    def make_compile_command(self):
        command = ["cc", "-o", "{targets}", "-Wall", "-Werror", "-g", "-O2"]
        command += ["-I" + d for d in self.kw.get("includes", [])]
        command += ["-c", "{sources}"]
        return " ".join(command)

    def make_obj(self, src):
        command = self.make_compile_command()
        o = join(self.dirpath, change_ext(src, ".o"))
        return Node(o, Node(join(self.dirpath, src), None, []), command)

    def make_target(self, target, objs):
        link_cmd = "cc -o {targets} {sources}"
        return Node(join(self.dirpath, target), objs, link_cmd)

    def construct_dependencies(self):
        objs = [self.make_obj(src) for src in self.sources]
        return [self.make_target(target, objs) for target in self.targets]

class Build:

    def __init__(self, dirpath):
        self.dirpath = dirpath
        self.subdirs = []
        self.tasks = []

    def command(self, commands, targets, sources):
        if not isinstance(commands, list):
            return self.command([commands], targets, sources)
        if not isinstance(targets, list):
            return self.command(commands, [targets], sources)
        if not isinstance(sources, list):
            return self.command(commands, targets, [sources])
        self.tasks.append(Command(self.dirpath, commands, targets, sources))

    def recurse(self, subdirs):
        if not isinstance(subdirs, list):
            return self.recurse([subdirs])
        self.subdirs += subdirs

    def glob(self, pat):
        cwd = getcwd()
        chdir(self.dirpath)
        try:
            return glob(pat)
        finally:
            chdir(cwd)

    def program(self, targets, sources, **kw):
        if not isinstance(targets, list):
            return self.program([targets], sources, **kw)
        if not isinstance(sources, list):
            return self.program(targets, [sources], **kw)
        self.tasks.append(Program(self.dirpath, targets, sources, **kw))

def construct_dependencies(tasks):
    roots = []
    for task in tasks:
        roots += task.construct_dependencies()
    return roots

def is_up_to_date(node):
    try:
        target_mtime = stat(node.name).st_mtime
        for source in node.sources:
            if source is None:
                continue
            source_mtime = stat(source.name).st_mtime
            if target_mtime < source_mtime:
                return False
    except FileNotFoundError:
        return False
    return True

def resolve(top_dir, node):
    if node is None:
        return
    for source in node.sources:
        resolve(top_dir, source)
    if is_up_to_date(node):
        return
    for fmt in node.commands:
        sources = " ".join([n.name for n in node.sources if n is not None])
        d = {
                "targets": node.name,
                "sources": sources,
                "top_dir": top_dir }
        command = fmt.format(**d)
        if call(command, shell=True) != 0:
            raise Exception("Command failed: {command}".format(**locals()))

def build(top_dir, dirpath):
    settings = run_path(join(dirpath, DAMEFILE))
    b = Build(dirpath)
    g = {
            "command": b.command,
            "program": b.program,
            "glob": b.glob,
            "recurse": b.recurse }
    update_globals(settings, g)
    settings["build"]()
    for subdir in b.subdirs:
        build(top_dir, join(dirpath, subdir))
    for node in construct_dependencies(b.tasks):
        resolve(top_dir, node)

def get_request():
    try:
        return argv[1]
    except IndexError:
        return "build"

def main():
    top_dir = abspath(".")
    d = {
            "build": partial(build, top_dir, top_dir),
            "configure": configure }
    d[get_request()]()

main()

# vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4
