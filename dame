#!/usr/bin/env python3

from os import close, unlink, write
from os.path import splitext
from runpy import run_path
from subprocess import PIPE, Popen
from sys import argv
import tempfile

class Configure:

    def __init__(self):
        self.headers = []
        self.functions = []
        self.errno = []
        self.sizeof = []
        self.libraries = []
        self.prefix = ""
        self.config_h_path = None
        self.definitions = []

    def define(self, key, value):
        self.definitions.append((key, value))

    def make_config_h(self, path):
        self.config_h_path = path

    def define_prefix(self, prefix):
        self.prefix = prefix

    def check_header(self, names):
        if isinstance(names, str):
            return self.check_header([names])
        self.headers += names

    def check_func(self, names):
        if isinstance(names, str):
            return self.check_func([names])
        self.functions += names

    def check_errno(self, names):
        if isinstance(names, str):
            return self.check_errno([names])
        self.errno += names

    def check_sizeof(self, names):
        if isinstance(names, str):
            return self.check_sizeof([names])
        self.sizeof += names

    def check_lib(self, names):
        if isinstance(names, str):
            return self.check_lib([names])
        self.libraries += names

def mkstemp():
    return tempfile.mkstemp(prefix="dame", suffix=".c")

def run_cc(src, flags):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path] + flags
        with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
            try:
                stdout, _ = proc.communicate()
            finally:
                try:
                    unlink(exe)
                except FileNotFoundError:
                    pass
            return proc.returncode, stdout
    finally:
        unlink(path)

def make_config_name(name):
    upper = name.upper()
    for c in [" ", "/", "."]:
        upper = upper.replace(c, "_")
    return upper

def add_definition(prefix, config_h, name):
    fmt = "{prefix}HAVE_{name}"
    config_h.append((fmt.format(prefix=prefix, name=make_config_name(name)), 1))

def add_definition_if_zero(prefix, config_h, name, src, flags=[]):
    if isinstance(flags, str):
        return add_definition_if_zero(prefix, config_h, name, src, [flags])

    status, _ = run_cc(src, flags)
    if status != 0:
        return
    add_definition(prefix, config_h, name)

def check_header(prefix, config_h, name):
    src = """\
#include <{name}>

int
main(int argc, const char* argv[])
{{
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, name, src)

def check_func(prefix, config_h, func):
    src = """\
int
main(int argc, const char* argv[])
{{
    void {func}();
    {func}();
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, func, src)

def check_errno(prefix, config_h, errno):
    src = """\
#include <errno.h>

int
main(int argc, const char* argv[])
{{
    {errno};
    return 0;
}}
""".format(**locals())
    add_definition_if_zero(prefix, config_h, errno, src)

def run_src(src):
    fd, path = mkstemp()
    try:
        write(fd, bytes(src, "ascii"))
        close(fd)

        exe = splitext(path)[0]
        cmd = ["cc", "-o", exe, path]
        try:
            with Popen(cmd, stdout=PIPE, stderr=PIPE) as proc:
                proc.communicate()
                if proc.returncode != 0:
                    raise Exception("Cannot compile a given code.")
            with Popen(exe, stdout=PIPE) as proc:
                stdout, _ = proc.communicate()
                return stdout
        finally:
            try:
                unlink(exe)
            except FileNotFoundError:
                pass
    finally:
        unlink(path)

def check_sizeof(prefix, config_h, name):
    src = """\
#include <stdio.h>

int
main(int argc, const char* argv[])
{{
    printf("%zu", sizeof({name}));
    return 0;
}}
""".format(**locals())
    stdout = run_src(src)

    fmt = "{prefix}SIZEOF_{name}"
    s = make_config_name(name.replace("*", "P"))
    config_h.append((fmt.format(prefix=prefix, name=s), int(stdout)))

def check_lib(prefix, config_h, lib):
    src = """\
int
main(int argc, const char* argv[])
{
    return 0;
}
"""
    add_definition_if_zero(prefix, config_h, lib, src, "-l" + lib)

def quote_if_str(val):
    return "\"{val}\"".format(**locals()) if isinstance(val, str) else val

def make_config_h(path, config_h):
    guard = make_config_name(path)
    with open(path, "w") as fp:
        write = fp.write
        write("""\
#ifndef {guard}
#define {guard}
""".format(**locals()))
        for key, value in config_h:
            v = quote_if_str(value)
            write("#define {key} {v}\n".format(**locals()))
        write("""\
#endif
""")

def configure():
    settings = run_path("Damefile")

    conf = Configure()
    g = {
            "define": conf.define,
            "make_config_h": conf.make_config_h,
            "define_prefix": conf.define_prefix,
            "check_header": conf.check_header,
            "check_func": conf.check_func,
            "check_errno": conf.check_errno,
            "check_sizeof": conf.check_sizeof,
            "check_lib": conf.check_lib }
    # ???: I expected settings["configure"].__globals__ keeps init_global, but
    # actual is wrong.
    for key in settings.keys():
        value = settings[key]
        if not callable(value):
            continue
        value.__globals__.update(g)
        value.__globals__.update(settings)
    settings["configure"]()

    prefix = conf.prefix
    config_h = []
    for header in conf.headers:
        check_header(prefix, config_h, header)
    for function in conf.functions:
        check_func(prefix, config_h, function)
    for errno in conf.errno:
        check_errno(prefix, config_h, errno)
    for sizeof in conf.sizeof:
        check_sizeof(prefix, config_h, sizeof)
    for library in conf.libraries:
        check_lib(prefix, config_h, library)
    config_h += conf.definitions
    make_config_h(conf.config_h_path, config_h)

def main():
    if argv[1] == "configure":
        configure()

main()

# vim: tabstop=4 shiftwidth=4 expandtab softtabstop=4
