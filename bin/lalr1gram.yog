#!/usr/bin/env yog-generational
# -*- coding: utf-8 -*-

class Token
  def init(type, value=nil)
    self.type = type
    self.value = value
  end
end

class Lexer
  def init(fp)
    self.fp = fp
    self.line = ""
    self.pos = 0
  end

  def read_line()
    self.line = self.fp.readline()
    self.pos = 0
  end

  def skip_whitespace()
    m = /\s*/.match(self.line, self.pos)
    if m == nil
      return
    end
    self.pos = m.end()
  end

  def read_action()
    action = ""
    while ((line = self.fp.readline()) != nil) && (line.rtrim() != "}")
      action += line
    end
    self.read_line()
    return action
  end

  def get_next_token()
    if self.line == nil
      return nil
    end
    self.skip_whitespace()
    if self.line.size <= self.pos
      self.read_line()
      return self.get_next_token()
    end

    if (m = /[a-z_]+/.match(self.line, self.pos)) != nil
      self.pos = m.end()
      size = m.end() - m.start()
      return Token.new('nonterminal, self.line.slice(m.start(), size).to_sym())
    end
    if (m = /<[a-z_]+>/.match(self.line, self.pos)) != nil
      self.pos = m.end()
      size = m.end() - m.start() - 2
      return Token.new('terminal, self.line.slice(m.start() + 1, size).to_sym())
    end
    { "->": 'arrow, "@": 'at, ":": 'colon }.each() do [key, value]
      if self.line.slice(self.pos, key.size) != key
        next
      end
      self.pos += key.size
      return Token.new(value)
    end
    if self.line[self.pos] == "{"
      self.pos = 0
      return Token.new('action, self.read_action())
    end
  end
end

def main(dest, src)
  File.open(src) do [fp]
    lexer = Lexer.new(fp)
    while (token = lexer.get_next_token()) != nil
      puts(token)
    end
  end
end

if __FILE__ == ARGV.get(0)
  main(ARGV[1], ARGV[2])
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
